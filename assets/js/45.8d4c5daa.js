(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{469:function(_,v,t){"use strict";t.r(v);var a=t(2),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"进程管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程管理"}},[_._v("#")]),_._v(" 进程管理")]),_._v(" "),v("p",[_._v("就是CPU管理")]),_._v(" "),v("p",[_._v("将CPU资源分配内XX进程")]),_._v(" "),v("p",[_._v("本质上是通过改变CPU的指向去调用进程")]),_._v(" "),v("p",[_._v("所以,操作系统对处理器的管理")]),_._v(" "),v("p",[_._v("可以简化成对进程的管理")]),_._v(" "),v("h2",{attrs:{id:"一-进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一-进程"}},[_._v("#")]),_._v(" 一.进程")]),_._v(" "),v("p",[_._v("什么是进程和线程就不说了")]),_._v(" "),v("p",[_._v("书上都有")]),_._v(" "),v("p",[_._v("说几个重要的")]),_._v(" "),v("h3",{attrs:{id:"_1-线程的控制结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-线程的控制结构"}},[_._v("#")]),_._v(" 1.线程的控制结构")]),_._v(" "),v("p",[_._v("包括这几个东西:")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("程序段")]),_._v(":进程包含的指令集合")]),_._v(" "),v("li",[v("strong",[_._v("数据段")]),_._v(":进程私有的数据")]),_._v(" "),v("li",[v("strong",[_._v("PCB")]),_._v(":程序控制块,包含进程的具体信息")])]),_._v(" "),v("h3",{attrs:{id:"_2-pcb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-pcb"}},[_._v("#")]),_._v(" 2.PCB")]),_._v(" "),v("p",[_._v("程序控制块,包含挺多重要信息:")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("进程描述信息")]),_._v(" "),v("p",[_._v("包括进程id和用户id")])]),_._v(" "),v("li",[v("p",[_._v("进程控制信息")]),_._v(" "),v("p",[_._v("包括进程当前状态以及优先级")])]),_._v(" "),v("li",[v("p",[_._v("CPU相关信息")])]),_._v(" "),v("li",[v("p",[_._v("资源分配清单")])])]),_._v(" "),v("p",[_._v("我们之前说")]),_._v(" "),v("p",[_._v("对CPU的管理本质是对进程的管理")]),_._v(" "),v("p",[_._v("那么对进程的管理本质就是对PCB的管理")]),_._v(" "),v("p",[_._v("PCB通过一个双向链表互相连接,找到下一个进程")]),_._v(" "),v("h3",{attrs:{id:"_3-进程的上下文切换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程的上下文切换"}},[_._v("#")]),_._v(" 3.进程的上下文切换")]),_._v(" "),v("p",[_._v("一个进程切换到另一个进程就叫上下文切换")]),_._v(" "),v("p",[_._v("在切换过程中,需要将旧进程的现场信息(CPU寄存器和PC)进行一个保存")]),_._v(" "),v("p",[_._v("以便待会接着进行")]),_._v(" "),v("p",[_._v("然后加载新的进程")]),_._v(" "),v("h3",{attrs:{id:"_4-进程的五态模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-进程的五态模型"}},[_._v("#")]),_._v(" 4.进程的五态模型")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.png",alt:"image-20240110170740083"}})]),_._v(" "),v("p",[_._v("如图为进程的五态模型:")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("创建")]),_._v(" "),v("p",[_._v("创建完成后进入就绪队列,就绪状态")])]),_._v(" "),v("li",[v("p",[_._v("就绪")]),_._v(" "),v("p",[_._v("CPU调度后变为运行状态")]),_._v(" "),v("p",[_._v("也可能因为时间片到了从运行状态到就绪状态")])]),_._v(" "),v("li",[v("p",[_._v("运行")]),_._v(" "),v("p",[_._v("完成任务进入销毁状态")]),_._v(" "),v("p",[_._v("时间片到进入就绪状态")]),_._v(" "),v("p",[_._v("IO事件或者等待资源进入阻塞状态")])]),_._v(" "),v("li",[v("p",[_._v("阻塞")]),_._v(" "),v("p",[_._v("IO或者等待资源结束后进入就绪状态")])]),_._v(" "),v("li",[v("p",[_._v("销毁")]),_._v(" "),v("p",[_._v("进程生命结束")])])]),_._v(" "),v("h2",{attrs:{id:"二-线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-线程"}},[_._v("#")]),_._v(" 二.线程")]),_._v(" "),v("p",[_._v("一个进程可以创建多个线程")]),_._v(" "),v("p",[_._v("一个线程只属于一个进程")]),_._v(" "),v("h3",{attrs:{id:"_1-线程进程的联系与区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-线程进程的联系与区别"}},[_._v("#")]),_._v(" 1.线程进程的联系与区别")]),_._v(" "),v("p",[_._v("进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位")]),_._v(" "),v("p",[_._v("最大的区别就是进程拥有独立的4G的虚拟地址空间")]),_._v(" "),v("p",[_._v("用来装寄存器与栈")]),_._v(" "),v("h3",{attrs:{id:"_2-为什么引入线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么引入线程"}},[_._v("#")]),_._v(" 2.为什么引入线程")]),_._v(" "),v("p",[_._v("线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程")]),_._v(" "),v("p",[_._v("而且")]),_._v(" "),v("p",[_._v("多线程并发编程正是开发高并发系统的基础")]),_._v(" "),v("h3",{attrs:{id:"_3-线程的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程的实现"}},[_._v("#")]),_._v(" 3.线程的实现")]),_._v(" "),v("p",[_._v("包括")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("用户线程")]),_._v("：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；")]),_._v(" "),v("li",[v("strong",[_._v("内核线程")]),_._v("：在内核中实现的线程，是由内核管理的线程")])]),_._v(" "),v("h2",{attrs:{id:"三-进程调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三-进程调度"}},[_._v("#")]),_._v(" 三.进程调度")]),_._v(" "),v("p",[_._v("进程调度算法就简单介绍一下吧")]),_._v(" "),v("p",[_._v("进程调度的衡量标准为"),v("strong",[_._v("周转时间")])]),_._v(" "),v("p",[_._v("计算方式如下:")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("完成时间-提交时间")])]),_._v(" "),v("li",[v("p",[_._v("运行时间+等待时间")])])]),_._v(" "),v("p",[_._v("介绍一下调度算法")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("先来先服务算法FCFS")])]),_._v(" "),v("p",[_._v("谁先来谁就先运行")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("短作业优先算法SJF")])]),_._v(" "),v("p",[_._v("选择估计运行时间最短的进程执行")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("时间片轮转算法RR")])]),_._v(" "),v("p",[_._v("在先来先服务的基础上")]),_._v(" "),v("p",[_._v("以时间片为基础调度")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("高响应比调度算法HRRF")])]),_._v(" "),v("p",[_._v("响应比 = 1 + 等待时间/运行时间")]),_._v(" "),v("p",[_._v("每次调度计算响应比,将高响应比进程占用CPU")])])]),_._v(" "),v("hr"),_._v(" "),v("p",[_._v("先说这么多")]),_._v(" "),v("p",[_._v("进程管理还有同步与通信,接下来我们慢慢说")])])}),[],!1,null,null,null);v.default=s.exports}}]);