(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{500:function(_,v,a){"use strict";a.r(v);var e=a(2),t=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"一-threadlocal"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一-threadlocal"}},[_._v("#")]),_._v(" 一. ThreadLocal")]),_._v(" "),v("h3",{attrs:{id:"_1-什么是threadlocal"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是threadlocal"}},[_._v("#")]),_._v(" 1.什么是ThreadLocal")]),_._v(" "),v("blockquote",[v("p",[_._v("线程本地存储机制")])]),_._v(" "),v("p",[v("strong",[v("code",[_._v("ThreadLocal")]),_._v("类主要解决的就是让每个线程绑定自己的值，可以将"),v("code",[_._v("ThreadLocal")]),_._v("类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。")])]),_._v(" "),v("h3",{attrs:{id:"_2-操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-操作"}},[_._v("#")]),_._v(" 2.操作")]),_._v(" "),v("h4",{attrs:{id:"put操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#put操作"}},[_._v("#")]),_._v(" put操作")]),_._v(" "),v("p",[v("code",[_._v("ThreadLocalMap")]),_._v(" 为 "),v("code",[_._v("ThreadLocal")]),_._v(" 的一个静态内部类，里面定义了"),v("code",[_._v("Entry")]),_._v(" 来保存数据.")]),_._v(" "),v("p",[_._v("在"),v("code",[_._v("Entry")]),_._v("内部使用"),v("code",[_._v("ThreadLocal")]),_._v("作为"),v("code",[_._v("key")]),_._v("(是弱引用)，使用我们设置的"),v("code",[_._v("value")]),_._v("作为"),v("code",[_._v("value")]),_._v("。")]),_._v(" "),v("p",[_._v("####　get操作")]),_._v(" "),v("p",[_._v("首先获取当前线程，然后通过"),v("code",[_._v("key threadlocal")]),_._v(" 获取 设置的"),v("code",[_._v("value")]),_._v(" 。")]),_._v(" "),v("h3",{attrs:{id:"_3-内存泄漏"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存泄漏"}},[_._v("#")]),_._v(" 3.内存泄漏")]),_._v(" "),v("p",[_._v("如果ThreadLocal是null")]),_._v(" "),v("p",[_._v("会被垃圾回收器回收")]),_._v(" "),v("p",[_._v("但是ThreadLocalMap的生命周期和Thread一样不会被回收")]),_._v(" "),v("p",[_._v("这是,ThreadLocalMap的Key没了,但value还在就造成了内存泄漏")]),_._v(" "),v("p",[v("strong",[_._v("解决方式")]),_._v(":")]),_._v(" "),v("p",[_._v("使用完ThreadLocal后执行remove操作")]),_._v(" "),v("h2",{attrs:{id:"二-aqs"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-aqs"}},[_._v("#")]),_._v(" 二.AQS")]),_._v(" "),v("h3",{attrs:{id:"_1-什么是aqs"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是aqs"}},[_._v("#")]),_._v(" 1. 什么是AQS?")]),_._v(" "),v("blockquote",[v("p",[_._v("JDK提供的一个同步框架,内部维护这FIFO双向队列,AQS依赖它来完成同步状态管理")])]),_._v(" "),v("p",[_._v("如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。")]),_._v(" "),v("p",[_._v("如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 "),v("strong",[_._v("CLH 队列锁")]),_._v(" 实现的，即将暂时获取不到锁的线程加入到队列中")]),_._v(" "),v("p",[_._v("AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。")]),_._v(" "),v("p",[_._v("AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。")]),_._v(" "),v("h3",{attrs:{id:"_2-aqs原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-aqs原理"}},[_._v("#")]),_._v(" 2.AQS原理")]),_._v(" "),v("p",[_._v("AQS维护了与i个 volatile int state 变量 和 一个 CLH 双向队列")]),_._v(" "),v("p",[_._v("state变量:")]),_._v(" "),v("ul",[v("li",[_._v("0 : 表示没有任何线程竞争锁资源")]),_._v(" "),v("li",[_._v("1 : 表示已经有线程正在持有锁资源")])]),_._v(" "),v("p",[_._v("队列中的节点持有线程引用，每个节点均可通过"),v("code",[_._v("getState()")]),_._v("、"),v("code",[_._v("setState()")]),_._v("和"),v("code",[_._v("compareAndSetState()")]),_._v("对"),v("code",[_._v("state")]),_._v("进行修改和访问")]),_._v(" "),v("p",[v("strong",[_._v("当线程获取锁时")]),_._v("，即试图对"),v("code",[_._v("state")]),_._v("变量做修改，如修改成功则获取锁；如修改失败则包装为节点挂载到队列中，等待持有锁的线程释放锁并"),v("strong",[_._v("唤醒")]),_._v("队列中的节点。")]),_._v(" "),v("p",[v("strong",[_._v("未获取到锁")]),_._v("的线程会被阻塞,加入到双向队列中")]),_._v(" "),v("h3",{attrs:{id:"_3-aqs核心结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-aqs核心结构"}},[_._v("#")]),_._v(" 3.AQS核心结构")]),_._v(" "),v("h4",{attrs:{id:"_1-node"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-node"}},[_._v("#")]),_._v(" 1. Node")]),_._v(" "),v("p",[_._v("如果AQS"),v("strong",[_._v("线程")]),_._v("获取资源失败,会包装成一个节点挂在到CLH队列上")]),_._v(" "),v("p",[_._v("Node类主要包括五个字段")]),_._v(" "),v("ul",[v("li",[_._v("waitStatus : 当前节点状态,共有五个取值\n"),v("ul",[v("li",[_._v("1 --- 节点引用线程由于等待超时或被打断时的状态")]),_._v(" "),v("li",[_._v("-1 --- 后继节点线程需要被唤醒时的当前节点状态,表示需要被唤醒")]),_._v(" "),v("li",[_._v("-2 --- 当节点线程进入 condition 队列时的状态")]),_._v(" "),v("li",[_._v("-3 --- 仅当释放共享锁 releaseShare时对头节点时使用")]),_._v(" "),v("li",[_._v("0 --- 节点初始化状态")])])]),_._v(" "),v("li",[_._v("prev : 前驱节点")]),_._v(" "),v("li",[_._v("next : 后继节点")]),_._v(" "),v("li",[_._v("thread : 应用线程 , 头节点不包含线程")]),_._v(" "),v("li",[_._v("nextWaiter ; condition 条件队列")])]),_._v(" "),v("h4",{attrs:{id:"_2-独占锁分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-独占锁分析"}},[_._v("#")]),_._v(" 2.独占锁分析")]),_._v(" "),v("h5",{attrs:{id:"acquire"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#acquire"}},[_._v("#")]),_._v(" acquire")]),_._v(" "),v("p",[v("code",[_._v("acquire")]),_._v("核心为"),v("code",[_._v("tryAcquire")]),_._v("、"),v("code",[_._v("addWaiter")]),_._v("和"),v("code",[_._v("acquireQueued")]),_._v("三个函数，其中"),v("code",[_._v("tryAcquire")]),_._v("需具体类实现。 每当线程调用"),v("code",[_._v("acquire")]),_._v("时都首先会调用"),v("code",[_._v("tryAcquire")]),_._v("，失败后才会挂载到队列，因此"),v("code",[_._v("acquire")]),_._v("实现"),v("strong",[_._v("默认为非公平锁")]),_._v("。")]),_._v(" "),v("p",[v("code",[_._v("addWaiter")]),_._v("将线程包装为独占节点，尾插式加入到队列中，如队列为空，则会添加一个空的头节点。值得注意的是"),v("code",[_._v("addWaiter")]),_._v("中的"),v("code",[_._v("enq")]),_._v("方法，通过"),v("code",[_._v("CAS+自旋")]),_._v("的方式处理尾节点添加冲突。")]),_._v(" "),v("p",[v("code",[_._v("acquireQueue")]),_._v("在线程节点加入队列后判断是否可再次尝试获取资源，如不能获取则将其前驱节点标志为"),v("code",[_._v("SIGNAL")]),_._v("状态(表示其需要被"),v("code",[_._v("unpark")]),_._v("唤醒)后，则通过"),v("code",[_._v("park")]),_._v("进入阻塞状态。")]),_._v(" "),v("h5",{attrs:{id:"release"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#release"}},[_._v("#")]),_._v(" release")]),_._v(" "),v("p",[v("code",[_._v("release")]),_._v("流程较为简单，尝试释放成功后，即从头结点开始唤醒其后继节点，如后继节点被取消，则转为从尾部开始找阻塞的节点将其唤醒。阻塞节点被唤醒后，即进入"),v("code",[_._v("acquireQueued")]),_._v("中的"),v("code",[_._v("for(;;)")]),_._v("循环开始新一轮的资源竞争。")]),_._v(" "),v("h4",{attrs:{id:"_3-共享锁分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-共享锁分析"}},[_._v("#")]),_._v(" 3.共享锁分析")]),_._v(" "),v("p",[_._v("即读锁")]),_._v(" "),v("p",[v("code",[_._v("acquireShared")]),_._v("和"),v("code",[_._v("releaseShared")]),_._v("整体流程与独占锁类似，"),v("code",[_._v("tryAcquireShared")]),_._v("获取失败后以"),v("code",[_._v("Node.SHARED")]),_._v("挂载到队尾阻塞，直到队头节点将其唤醒。在"),v("code",[_._v("doAcquireShared")]),_._v("与独占锁不同的是，由于共享锁是可以被多个线程获取的，因此在首个阻塞节点被唤醒后，会通过"),v("code",[_._v("setHeadAndPropagate")]),_._v("传递唤醒后续的阻塞节点。")])])}),[],!1,null,null,null);v.default=t.exports}}]);