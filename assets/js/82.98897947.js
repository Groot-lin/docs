(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{509:function(_,v,t){"use strict";t.r(v);var r=t(2),a=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("MQ的可靠性主要是由三个方面来")]),_._v(" "),v("ol",[v("li",[_._v("生产者可靠性")]),_._v(" "),v("li",[_._v("MQ可靠性")]),_._v(" "),v("li",[_._v("消费者可靠性")])]),_._v(" "),v("h2",{attrs:{id:"一-生产者可靠性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一-生产者可靠性"}},[_._v("#")]),_._v(" 一.生产者可靠性")]),_._v(" "),v("p",[_._v("生产者的可靠性主要依靠两个手段去解决")]),_._v(" "),v("h3",{attrs:{id:"_1-生产者重连"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-生产者重连"}},[_._v("#")]),_._v(" 1.生产者重连")]),_._v(" "),v("p",[_._v("当"),v("strong",[_._v("网络不稳定")]),_._v("时,利用重试机制可以有效提高消息发送的成功率")]),_._v(" "),v("p",[_._v("但是SpringAMQP提供的重试机制时阻塞式的重试")]),_._v(" "),v("p",[_._v("在多次重试等待过程中,当前线程是被阻塞的,会影响业务性能")]),_._v(" "),v("h3",{attrs:{id:"_2-生产者确认"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-生产者确认"}},[_._v("#")]),_._v(" 2.生产者确认")]),_._v(" "),v("p",[_._v("与生产者重连不同,生产者确认侧重于"),v("strong",[_._v("消息发送失败")]),_._v("的场景")]),_._v(" "),v("p",[_._v("RabbitMQ提供了"),v("strong",[_._v("Publisher Confirm")]),_._v("和"),v("strong",[_._v("Publisher Return")]),_._v("两种确认机制")]),_._v(" "),v("p",[_._v("开启确认机制后,在MQ成功收到消息后会返回确认消息给生产者")]),_._v(" "),v("p",[_._v("有以下几种情况 :")]),_._v(" "),v("ul",[v("li",[_._v("消息投递到MQ,但是路由失败.此时会通过"),v("strong",[_._v("Publisher Return")]),_._v("返回路由异常原因,然后返回"),v("font",{attrs:{color:"red"}},[_._v("ACK")]),_._v(",告知投递成功")],1),_._v(" "),v("li",[_._v("临时消息投递到了MQ,并且入队成功,返回"),v("font",{attrs:{color:"red"}},[_._v("ACK")]),_._v(",告知投递成功")],1),_._v(" "),v("li",[_._v("持久消息投递到了MQ,并且入队成功持久化,返回"),v("font",{attrs:{color:"red"}},[_._v("ACK")]),_._v(",告知投递成功")],1),_._v(" "),v("li",[_._v("其他情况都会返回"),v("font",{attrs:{color:"red"}},[_._v("NACK")]),_._v(",告知投递失败")],1)]),_._v(" "),v("blockquote",[v("p",[_._v("如何判断是否投递成功呢?")])]),_._v(" "),v("p",[_._v("生产者将Channel设置成Confirm模式，当设置Confirm模式后")]),_._v(" "),v("p",[_._v("所有在该信道上面发布的消息都会被指派一个"),v("strong",[_._v("唯一的ID")]),_._v("(从1开始，ID在同个Channel范围是唯一的)")]),_._v(" "),v("p",[_._v("一旦消息被投递到所有匹配的队列之后MQ就会发送一个确认给生产者(包含消息的唯一ID)")]),_._v(" "),v("p",[_._v("这就使得生产者知道消息已经正确到达目的队列了")]),_._v(" "),v("p",[_._v("从而正确发送Ack")]),_._v(" "),v("h3",{attrs:{id:"_3-事务机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务机制"}},[_._v("#")]),_._v(" 3.事务机制")]),_._v(" "),v("p",[_._v("RabbitMQ支持事务机制")]),_._v(" "),v("p",[_._v("这种方式有明显的缺点， 即RabbitMQ事务开启后，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性 能会造成吞吐量的下降")]),_._v(" "),v("h2",{attrs:{id:"二-mq的可靠性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-mq的可靠性"}},[_._v("#")]),_._v(" 二.MQ的可靠性")]),_._v(" "),v("p",[_._v("经过生产可靠性的部分操作")]),_._v(" "),v("p",[_._v("我们已经确认消息已经到达MQ了")]),_._v(" "),v("p",[_._v("但是如果消息在MQ中丢失又该如何应对呢?")]),_._v(" "),v("p",[_._v("首先我们要明白,MQ为什么会丢消息?")]),_._v(" "),v("blockquote",[v("p",[_._v("MQ为什么会丢消息?")])]),_._v(" "),v("p",[_._v("这是因为在默认情况下,RabbitMQ会将接收到的信息保存在"),v("strong",[_._v("内存中")]),_._v("以降低消息收发的延迟")]),_._v(" "),v("ul",[v("li",[_._v("一旦MQ宕机,内存中消息丢失")]),_._v(" "),v("li",[_._v("内存空间有限,当消费者故障或者处理过满,会导致消息积压,引发MQ阻塞")])]),_._v(" "),v("p",[_._v("我们使用两种手段应对:")]),_._v(" "),v("h3",{attrs:{id:"_1-数据持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据持久化"}},[_._v("#")]),_._v(" 1.数据持久化")]),_._v(" "),v("p",[_._v("在3.6版本之后不再常用")]),_._v(" "),v("p",[_._v("RabbitMQ实现数据持久化包括三个方面:")]),_._v(" "),v("ol",[v("li",[_._v("交换机持久化")]),_._v(" "),v("li",[_._v("队列持久化")]),_._v(" "),v("li",[_._v("消息持久化")])]),_._v(" "),v("h3",{attrs:{id:"_2-lazy-queue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-lazy-queue"}},[_._v("#")]),_._v(" 2.Lazy Queue")]),_._v(" "),v("p",[_._v("RabbitMQ从3.6版本开始,增加了Lazy Queue的概念,即"),v("strong",[_._v("惰性队列")])]),_._v(" "),v("p",[_._v("特征如下 :")]),_._v(" "),v("ul",[v("li",[_._v("接收到消息后直接存入磁盘而非内存(内存中只保留最近的消息,默认2048条)")]),_._v(" "),v("li",[_._v("消费者要消费消息时才会从磁盘中读取并加载到内存")]),_._v(" "),v("li",[_._v("支持数百万条消息存储")])]),_._v(" "),v("p",[_._v("在3.12版本后,所有队列都是Lazy Queue模式,无法更改")]),_._v(" "),v("p",[_._v("这种方式保证内存也有消息,磁盘也有消息")]),_._v(" "),v("h2",{attrs:{id:"三-消费者可靠性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三-消费者可靠性"}},[_._v("#")]),_._v(" 三.消费者可靠性")]),_._v(" "),v("p",[_._v("经过以上两步")]),_._v(" "),v("p",[_._v("我们可以确认消息成功到达MQ且不再丢失")]),_._v(" "),v("p",[_._v("现在压力来到消费者")]),_._v(" "),v("p",[_._v("消费者同样有三个手段去应对")]),_._v(" "),v("h3",{attrs:{id:"_1-消费者确认机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-消费者确认机制"}},[_._v("#")]),_._v(" 1.消费者确认机制")]),_._v(" "),v("p",[_._v("为了确认消费者是否成功处理消息,RabbitMQ提供了消费者确认机制")]),_._v(" "),v("p",[_._v("消费者处理后,向RabbitMQ返回消息,告知处理状态")]),_._v(" "),v("p",[_._v("有三种返回值 :")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("ack")]),_._v(": 成功处理消息,RabbitMQ从队列中删除该消息")]),_._v(" "),v("li",[v("strong",[_._v("nack")]),_._v(" : 消息处理失败,RabbitMQ需要再次投递消息")]),_._v(" "),v("li",[v("strong",[_._v("reject")]),_._v(" : 消息处理失败并拒绝该消息,RabbitMQ从队列中删除该消息")])]),_._v(" "),v("p",[_._v("针对确认消费者是否安全消费消息")]),_._v(" "),v("p",[_._v("RabbitMQ存在以下三种机制")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("NONE")]),_._v(" : RabbitMQ消费者默认为自动确认,不管消费者是否成功消费了消息")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("AUTO")]),_._v(" : 不主动捕获异常，当消费过程中出现异常时会将消息放回 Queue中，然后消息会被重新分配到其他消费者节点（如果没有则还是选择当前节点）重新被消费，默认会一直重发消息并直到消费完成返回Ack或者一直到过期,可能存在死循环")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("MANUAL")]),_._v(" : 手动Ack,消费者自行控制流程,并手动调用相关方法返回")])])]),_._v(" "),v("h3",{attrs:{id:"_2-失败重试机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-失败重试机制"}},[_._v("#")]),_._v(" 2.失败重试机制")]),_._v(" "),v("p",[_._v("当消费者出现异常后，消息会不断requeue(重新入队）到队列")]),_._v(" "),v("p",[_._v("再重新发送给消费者，然后再次异常，再次requeue")]),_._v(" "),v("p",[_._v("无限循环,导致mq的消息处理飙升，带来不必要的压力")]),_._v(" "),v("p",[v("big",[v("strong",[_._v("本地重试")])])],1),_._v(" "),v("p",[_._v("我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列")]),_._v(" "),v("p",[v("u",[_._v("但是重试达到设定的最大次数时,Spring会返回Ack,消息会被丢弃")])]),_._v(" "),v("p",[_._v("这是Spring内部机制决定的")]),_._v(" "),v("p",[_._v("我们需要想一个失败策略")]),_._v(" "),v("p",[v("big",[v("strong",[_._v("失败策略")])])],1),_._v(" "),v("p",[_._v("在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同的实现：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("RejectAndDontRequeueRecoverer")]),_._v("：重试耗尽后，直接reject，丢弃消息。"),v("strong",[_._v("默认")]),_._v("就是这种方式")]),_._v(" "),v("li",[_._v("ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队")]),_._v(" "),v("li",[_._v("RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机")])])])}),[],!1,null,null,null);v.default=a.exports}}]);