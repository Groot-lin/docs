(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{486:function(_,t,v){"use strict";v.r(t);var e=v(2),a=Object(e.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"一-acid特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-acid特性"}},[_._v("#")]),_._v(" 一.ACID特性")]),_._v(" "),t("h3",{attrs:{id:"_1-原子性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-原子性"}},[_._v("#")]),_._v(" 1.原子性")]),_._v(" "),t("p",[_._v("MySQL把要么全做，要么全不做的规则称之为"),t("strong",[_._v("原子性")])]),_._v(" "),t("h3",{attrs:{id:"_2-一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-一致性"}},[_._v("#")]),_._v(" 2.一致性")]),_._v(" "),t("p",[_._v("事务完成时,所有数据保持一致")]),_._v(" "),t("h3",{attrs:{id:"_3-隔离性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-隔离性"}},[_._v("#")]),_._v(" 3.隔离性")]),_._v(" "),t("p",[_._v("两个事务之间互不影响")]),_._v(" "),t("h3",{attrs:{id:"_4-持久性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-持久性"}},[_._v("#")]),_._v(" 4.持久性")]),_._v(" "),t("p",[_._v("事务一旦提交,对数据库的操作是永久的")]),_._v(" "),t("h2",{attrs:{id:"二-bin-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-bin-log"}},[_._v("#")]),_._v(" 二.bin log")]),_._v(" "),t("p",[_._v("bin log日志是逻辑日志,记录内容是语句的原始逻辑.")]),_._v(" "),t("p",[_._v("所有的存储引擎只要发生了更新,都会产生binlog日志")]),_._v(" "),t("p",[_._v("MySQL数据库的"),t("strong",[_._v("数据备份、主备、主主、住从")]),_._v("都离不开binlog，需要依赖binlog来同步数据，保证数据一致性")]),_._v(" "),t("h2",{attrs:{id:"三-redo-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-redo-log"}},[_._v("#")]),_._v(" 三.redo log")]),_._v(" "),t("p",[_._v("目的:")]),_._v(" "),t("p",[_._v("让已经提交了的事务对数据库中数据所做的修改永久生效")]),_._v(" "),t("p",[_._v("即使后来系统崩溃，在重启后也能把这种修改恢复出来")]),_._v(" "),t("h3",{attrs:{id:"_1-如何保证事务一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何保证事务一致性"}},[_._v("#")]),_._v(" 1.如何保证事务一致性?")]),_._v(" "),t("ol",[t("li",[_._v("在事务提交完成之前把该事务所修改的在事务提交完成之前"),t("strong",[_._v("把该事务所修改的所有页面都刷新到磁盘")])])]),_._v(" "),t("p",[_._v("但是会产生两个问题")]),_._v(" "),t("p",[_._v("刷新一个完整的数据页太浪费了,虽然InnoDB是以页为单位进行磁盘IO,但是如果只修改一个字节就刷新16kb数据就显得有点浪费")]),_._v(" "),t("p",[_._v("随机IO刷起来太慢了,有时一条语句就要修改许多页,这些页很可能并不相邻")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[_._v("把修改的动作记录一下")])])]),_._v(" "),t("p",[_._v("在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的 步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足持久性的要求")]),_._v(" "),t("p",[_._v("上诉记录信息的方式被称为"),t("strong",[_._v("redo log(重做日志)")])]),_._v(" "),t("ul",[t("li",[_._v("redo log日志占用空间小")]),_._v(" "),t("li",[_._v("redo log日志是顺序写入磁盘的")])]),_._v(" "),t("h3",{attrs:{id:"_2-redo-log-日志格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-redo-log-日志格式"}},[_._v("#")]),_._v(" 2.redo log 日志格式")]),_._v(" "),t("p",[_._v("通用格式:")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[_._v("type")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("space ID")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("page number")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("data")])])]),_._v(" "),t("tbody")]),_._v(" "),t("ul",[t("li",[_._v("type : 该条redo日志的类型")]),_._v(" "),t("li",[_._v("spcae ID : 表空间ID")]),_._v(" "),t("li",[_._v("page number : 页号")]),_._v(" "),t("li",[_._v("data : 该条redo 日志的具体内容")])]),_._v(" "),t("h3",{attrs:{id:"_3-mini-transaction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-mini-transaction"}},[_._v("#")]),_._v(" 3.Mini-Transaction")]),_._v(" "),t("p",[_._v("MySQL认为向某个索引对应的 B+ 树中插入一条记录的这个过程必须是原子的，不能说插了一半之 后就停止了")]),_._v(" "),t("p",[_._v("比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中 了，可是没有向内节点中插入一条 目录项记录 ，这个插入过程就是不完整的，这样会形成一棵不正确的 B+ 树")]),_._v(" "),t("p",[_._v("我们知道 redo 日志是为了在系统奔溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分 redo 日志，那么在系统奔溃重启时会将索引对应的 B+ 树恢复成一种不正确的状态，这是设计 InnoDB 的大叔们所不能 忍受的")]),_._v(" "),t("p",[_._v("所以他们规定在执行这些需要保证原子性的操作时必须以 组 的形式来记录的 redo 日志，在进行系统奔 溃重启恢复时，针对某个组中的 redo 日志，要么把全部的日志都恢复掉，要么一条也不恢复")]),_._v(" "),t("p",[_._v("如何实现:")]),_._v(" "),t("ul",[t("li",[_._v("有的操作需要保证原子性操作会生成多条redolog日志")])]),_._v(" "),t("p",[_._v("mysql在该组中 的最后一条 redo 日志后边加上一条特殊类型的 redo 日志，该类型名称为 "),t("strong",[_._v("MLOG_MULTI_REC_END")]),_._v(",")]),_._v(" "),t("p",[_._v("这样在系统奔溃重启进行恢复时，只有当解析到类型为 MLOG_MULTI_REC_END 的 redo 日志，才认为解析到了 一组完整的 redo 日志，才会进行恢复,否则的话直接放弃前边解析到的 redo 日志")]),_._v(" "),t("ul",[t("li",[_._v("有的需要保证原子性的操作只生成一条 redo 日志")])]),_._v(" "),t("p",[_._v("如果 type 字段的第一个比特位为 1 ，代表该需要保证原子性的操作只产生了单一的一条 redo 日志，否则 表示该需要保证原子性的操作产生了一系列的 redo 日志")]),_._v(" "),t("p",[_._v("MySQL把对底层页面中的一次原子访问的过程称之为一个 "),t("strong",[_._v("Mini-Transaction")]),_._v(" ，简称 mtr.一个所谓的 mtr 可以包含一组 redo 日志，在进行奔溃恢复时这一组 redo 日志作为一个不可分割的整体")]),_._v(" "),t("h3",{attrs:{id:"_4-redo日志写入过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-redo日志写入过程"}},[_._v("#")]),_._v(" 4.redo日志写入过程")]),_._v(" "),t("h4",{attrs:{id:"_1-block"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-block"}},[_._v("#")]),_._v(" 1).block")]),_._v(" "),t("p",[_._v("MySQL为了更好的进行系统奔溃恢复，他们把通过 mtr 生成的 redo 日志都放在了大小为 512字节 的页中,我们这种页称为block")]),_._v(" "),t("p",[_._v("结构如下:")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[_._v("log block header")])])]),_._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("log block body")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("log block trailer")])])])]),_._v(" "),t("p",[_._v("真正的 redo 日志都是存储到占用 496 字节大小的 log block body 中")]),_._v(" "),t("h4",{attrs:{id:"_2-日志缓冲区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-日志缓冲区"}},[_._v("#")]),_._v(" 2).日志缓冲区")]),_._v(" "),t("p",[_._v("MySQL写入 redo 日 志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的 连续内存空间，翻译成中文就是 "),t("strong",[_._v("redo日志缓冲区")]),_._v(",简称log buffer")]),_._v(" "),t("p",[_._v("在log buffer中有个"),t("strong",[_._v("buf_free")]),_._v("全局变量,知名后续写入的redo log日志应该写入log buffer中的哪个位置")]),_._v(" "),t("h4",{attrs:{id:"_3-写入过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-写入过程"}},[_._v("#")]),_._v(" 3).写入过程")]),_._v(" "),t("p",[_._v("每个 mtr 运行过程中产生的日志先暂时存到 一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo 日志再全部复制到 log buffer 中")]),_._v(" "),t("h3",{attrs:{id:"_5-redo-log刷盘时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-redo-log刷盘时机"}},[_._v("#")]),_._v(" 5.redo log刷盘时机")]),_._v(" "),t("p",[_._v("mtr 运行过程中产生的一组 redo 日志在 mtr 结束时会被复制到 log buffer 中，可是这些日志无法一直呆在log buffer中，在一些情况下它们会被刷新到磁盘里:")]),_._v(" "),t("ul",[t("li",[_._v("log buffer 空间不足,超过一半就刷新到磁盘")]),_._v(" "),t("li",[_._v("事务提交")]),_._v(" "),t("li",[_._v("后台线程每秒刷新一次")]),_._v(" "),t("li",[_._v("正常关闭服务器时")])]),_._v(" "),t("h3",{attrs:{id:"_6-log-sequeue-number日志序列号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-log-sequeue-number日志序列号"}},[_._v("#")]),_._v(" 6.Log Sequeue Number日志序列号")]),_._v(" "),t("p",[_._v("自系统开始运行，就不断的在修改页面，也就意味着会不断的生成 redo 日志。 redo 日志的量在不断的递增，就 像人的年龄一样,自打出生起就不断递增，永远不可能缩减了")]),_._v(" "),t("p",[_._v("MySQL记录已经写入的 redo 日志 量，设计了一个称之为 "),t("strong",[_._v("Log Sequeue Number")]),_._v(" 的全局变量，翻译过来就是： 日志序列号 ，简称 lsn")]),_._v(" "),t("p",[_._v("初始值为 8704")]),_._v(" "),t("p",[_._v("我们知道在向 log buffer 中写入 redo 日志时不是一条一条写入的，而是以一个 mtr 生成的一组 redo 日志为单 位进行写入的。而且"),t("strong",[_._v("实际上是把日志内容写在了 log block body 处")]),_._v(",但是在统计 lsn 的增长量时，是按照实际"),t("strong",[_._v("写入的日志量加上占用的 log block header 和 log block trailer")]),_._v(" 来计算的")]),_._v(" "),t("p",[t("strong",[_._v("每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明 redo日志产生的越早")])]),_._v(" "),t("h3",{attrs:{id:"_7-flushed-to-disk-lsn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-flushed-to-disk-lsn"}},[_._v("#")]),_._v(" 7.flushed_to_disk_lsn")]),_._v(" "),t("p",[_._v("lsn 是表示当前系统中写入的 redo 日志量，这包括了写到 log buffer 而没有刷新到磁盘的日志， 相应的，设计 InnoDB 的大叔提出了一个"),t("strong",[_._v("表示刷新到磁盘中的 redo 日志量的全局变量")]),_._v("，称之为 "),t("strong",[_._v("flushed_to_disk_lsn")]),_._v(",初始值也是8704")]),_._v(" "),t("p",[_._v("flushed_to_disk_lsn值越大表示被刷新到磁盘的redolog越多")]),_._v(" "),t("h2",{attrs:{id:"四-undo-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-undo-log"}},[_._v("#")]),_._v(" 四.undo log")]),_._v(" "),t("p",[_._v("我们说过 事务 需要保证 原子性 ，也就是事务中的操作要么全部完成，要么什么也不做")]),_._v(" "),t("p",[_._v("但是偏偏有时候事务执 行到一半会出现一些情况")]),_._v(" "),t("p",[_._v("为了"),t("strong",[_._v("保证事务的原子性")]),_._v("，我们需要把东西改回原先的样子，这个过程就称之为 回滚")]),_._v(" "),t("p",[_._v("所以每当对一条记录做改动时,都需要"),t("strong",[_._v("把回滚时所需的东西给记录下来")])]),_._v(" "),t("p",[_._v("MySQL称之为 "),t("strong",[_._v("undo log(回滚日志)")])]),_._v(" "),t("h3",{attrs:{id:"_1-事务id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务id"}},[_._v("#")]),_._v(" 1.事务id")]),_._v(" "),t("p",[_._v("如果某个事务执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给它分配一个独一无二的 事务id")]),_._v(" "),t("p",[_._v("分配方式:")]),_._v(" "),t("ul",[t("li",[_._v("对只读事务来说,只有在它第一次对某个用户创建的临时表执行增删改操作时才会为这个事务分配一个事务id")]),_._v(" "),t("li",[_._v("对于读写事务来说,只有在它第一次对某个用户创建的临时表执行增删改操作时才会为这个事务分配一个事务id,否则的话是不分配事务id的")])]),_._v(" "),t("p",[t("big",[t("strong",[_._v("事务id如何生成?")])])],1),_._v(" "),t("p",[_._v("分配策略：")]),_._v(" "),t("ul",[t("li",[_._v("服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个 事务id 时，就会把该变量的值当作 事 务id 分配给该事务，并且把该变量自增1")]),_._v(" "),t("li",[_._v("每当这个变量的值为 256 的倍数时，就会将该变量的值刷新到系统表空间的页号为 5 的页面中一个称之为 Max Trx ID 的属性处，这个属性占用 8 个字节的存储空间")]),_._v(" "),t("li",[_._v("当系统下一次重新启动时，会将上边提到的 Max Trx ID 属性加载到内存中，将该值加上256之后赋值给我们 前边提到的全局变量（因为在上次关机时该全局变量的值可能大于 Max Trx ID 属性值）")])]),_._v(" "),t("p",[_._v("在compact行格式中")]),_._v(" "),t("p",[_._v("隐藏字段中就包含一个事务id的字段")]),_._v(" "),t("h3",{attrs:{id:"_2-undo日志格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-undo日志格式"}},[_._v("#")]),_._v(" 2.undo日志格式")]),_._v(" "),t("p",[_._v("undo log日志被放在类型为"),t("strong",[_._v("FIL_PAGEUNDO_LOG")]),_._v("的页面")]),_._v(" "),t("p",[_._v("这些页面可以从系统表空间中分配，也可以从一种专门存放 undo日志 的表空间，也就是undo tablespace 中分配")]),_._v(" "),t("h4",{attrs:{id:"_1-insert操作对应的undo日志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-insert操作对应的undo日志"}},[_._v("#")]),_._v(" 1).INSERT操作对应的undo日志")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/undoinsert.png",alt:"image-20231005200244127"}})]),_._v(" "),t("ul",[t("li",[t("p",[_._v("undo no在一个事务中是从0递增的,每生成一条undo日志,undo no+1")])]),_._v(" "),t("li",[t("p",[_._v("如果记录中的主键只包含一个列，那么在类型为 TRX_UNDO_INSERT_REC 的 undo日志 中只需要把该列占用的 存储空间大小和真实值记录下来，如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的 真实值都需要记录下来")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("roll_pointer")]),_._v("(行格式隐藏信息)本质就是一个指针，指向记录对应的undo日志(每条记录对应一个ubdo log)")])])]),_._v(" "),t("h4",{attrs:{id:"_2-delete操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-delete操作"}},[_._v("#")]),_._v(" 2).DELETE操作")]),_._v(" "),t("p",[_._v("我们知道插入到页面中的记录会根据记录头信息中的 next_record 属性组成一个单向链表，我们把这个链表称之 为 "),t("strong",[_._v("正常记录链表")])]),_._v(" "),t("p",[_._v("被删除的记录其实也会根据记录头信息中的 next_record 属性组成一个链表，就是一页里面维护两条链表,一条正常,一条垃圾,只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表 为 "),t("strong",[_._v("垃圾链表")]),_._v(" 。")]),_._v(" "),t("p",[_._v("Page Header 部分有一个称之为 "),t("strong",[_._v("PAGE_FREE")]),_._v(" 的属性，它指向由被删除记录组成的垃圾链表中的头节点")]),_._v(" "),t("p",[_._v("删除一条记录所经历的阶段:")]),_._v(" "),t("ol",[t("li",[_._v("delete mask : 将记录的"),t("strong",[_._v("delete_mask")]),_._v("设置为1")]),_._v(" "),t("li",[_._v("purge : 当该删除语句所在的"),t("strong",[_._v("事务提交之后")]),_._v("，会有专门的线程后来真正的把记录删除掉.就是把该记录从正常记录链表中移除并加入垃圾链表")])]),_._v(" "),t("h4",{attrs:{id:"_3-update操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-update操作"}},[_._v("#")]),_._v(" 3).UPDATE操作")]),_._v(" "),t("p",[t("big",[t("strong",[_._v("1.不更新主键的情况")])])],1),_._v(" "),t("ol",[t("li",[_._v("就地更新,存储空间不发生变化")])]),_._v(" "),t("p",[_._v("更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都"),t("strong",[_._v("一样大")]),_._v("，那么就可以进行就地更新")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("先删旧记录,再增新记录")])]),_._v(" "),t("p",[_._v("在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需 要先把这条旧的记录从聚簇索引页面中删除**(purge 操作)**掉，然后再根据更新后列的值创建一条新的记录插入到页面中")]),_._v(" "),t("p",[t("big",[t("strong",[_._v("2.更新主键的情况")])])],1),_._v(" "),t("p",[_._v("两步处理:")]),_._v(" "),t("ul",[t("li",[_._v("将旧纪录进行delete mask操作")]),_._v(" "),t("li",[_._v("根据更新后各列的值创建一条新纪录,并将其插入到聚簇索引中")])]),_._v(" "),t("h3",{attrs:{id:"_3-undo-log写入过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-undo-log写入过程"}},[_._v("#")]),_._v(" 3.undo log写入过程")]),_._v(" "),t("p",[_._v("对于没有被重用的 Undo页面 链表来说，链表的第一个页面，也就是 first undo page 在真正写入 undo日志 前，会填充 Undo Page Header 、 Undo Log Segment Header 、 Undo Log Header 这3个部分，之后才开始正式 写入 undo日志")]),_._v(" "),t("p",[_._v("对于其他的页面来说，也就是 normal undo page 在真正写入 undo日志 前，只会填充 Undo Page Header 。链表的 List Base Node 存放到 first undo page 的 Undo Log Segment Header 部分， List Node 信息存放到每一个 Undo页面 的 undo Page Header 部分")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/undolog%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.png",alt:"image-20231006162922263"}})]),_._v(" "),t("h3",{attrs:{id:"_4-重用undo页面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-重用undo页面"}},[_._v("#")]),_._v(" 4.重用Undo页面")]),_._v(" "),t("p",[_._v("前面提到为了能执行并发事务写入undolog日志,MySQL为每个事务单独分配相应的Ubdo页面链表,最多可能单独分配4个链表")]),_._v(" "),t("p",[_._v("但是如果每个事务就创建一个Undo页面过于浪费,于是MySQL决定在事务提交后某些情况下重用该事务的Undo页面链表")]),_._v(" "),t("p",[_._v("被重用条件:")]),_._v(" "),t("ul",[t("li",[_._v("该链表中只包含一个Undo页面")]),_._v(" "),t("li",[_._v("该Undo页面已经使用的空间小于整个页面空间的3/4")])]),_._v(" "),t("h2",{attrs:{id:"五-事务的隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五-事务的隔离级别"}},[_._v("#")]),_._v(" 五.事务的隔离级别")]),_._v(" "),t("h3",{attrs:{id:"_1-事务并发执行遇到的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务并发执行遇到的问题"}},[_._v("#")]),_._v(" 1.事务并发执行遇到的问题")]),_._v(" "),t("h4",{attrs:{id:"_1-脏写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-脏写"}},[_._v("#")]),_._v(" 1).脏写")]),_._v(" "),t("p",[_._v("如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了 "),t("strong",[_._v("脏写")])]),_._v(" "),t("h4",{attrs:{id:"_2-脏读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-脏读"}},[_._v("#")]),_._v(" 2).脏读")]),_._v(" "),t("p",[_._v("一个事务读到了另一个"),t("strong",[_._v("未提交事务修改后的数据")])]),_._v(" "),t("h4",{attrs:{id:"_3-不可重复读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-不可重复读"}},[_._v("#")]),_._v(" 3).不可重复读")]),_._v(" "),t("p",[_._v("一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值. "),t("strong",[_._v("在同一个事务中，对于同一组数据读取到的结果不一致")])]),_._v(" "),t("h4",{attrs:{id:"_4-幻读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-幻读"}},[_._v("#")]),_._v(" 4).幻读")]),_._v(" "),t("p",[_._v("一个事务先根据某些条件查询出一些记录,之后另一个事务又向表中插入了符合这些条件的记录,原先的事务再次按照该条件查询时,能把另一个事务插入的记录也读出来,"),t("strong",[_._v("两次读出的结果不一致")])]),_._v(" "),t("h3",{attrs:{id:"_2-sql标准中的四种隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-sql标准中的四种隔离级别"}},[_._v("#")]),_._v(" 2.SQL标准中的四种隔离级别")]),_._v(" "),t("p",[_._v("以上并发问题严重性排名")]),_._v(" "),t("p",[_._v("脏写 > 脏读 > 不可重复读 > 幻读")]),_._v(" "),t("p",[_._v("MySQL舍弃一部分隔离性来换取一部分性能:")]),_._v(" "),t("p",[_._v("设立一些隔离级别,隔离级别越低,越严重的的问题就越有可能发生")]),_._v(" "),t("p",[_._v("SQL标准设立了四个隔离级别:")]),_._v(" "),t("ul",[t("li",[_._v("READ UNCOMMITTED ：未提交读")]),_._v(" "),t("li",[_._v("READ COMMITTED ：已提交读")]),_._v(" "),t("li",[_._v("REPEATABLE READ ：可重复读")]),_._v(" "),t("li",[_._v("SERIALIZABLE ：可串行化")])]),_._v(" "),t("p",[_._v("针对不同隔离级别,并发事务可以发生不同程度严重问题")]),_._v(" "),t("p",[_._v("1 表示可能发生")]),_._v(" "),t("p",[_._v("0 表示不可能发生")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[_._v("隔离级别")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("脏读")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("不可重复读")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("幻读")])])]),_._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("READ UNCOMMITTED")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("READ COMMITTED")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("REPEATABLE READ")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("SERIALIZABLE")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")])])])]),_._v(" "),t("p",[t("strong",[_._v("脏写问题过于严重,任何隔离级别不允许发生")])]),_._v(" "),t("h3",{attrs:{id:"_3-mysql中支持的四种隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-mysql中支持的四种隔离级别"}},[_._v("#")]),_._v(" 3.MySQL中支持的四种隔离级别")]),_._v(" "),t("p",[_._v("MySQL在"),t("strong",[_._v("REPEATABLE READ")]),_._v("隔离级别下，是可以"),t("strong",[_._v("禁止幻读问题")]),_._v("的发生的")]),_._v(" "),t("h3",{attrs:{id:"_4-mvcc原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-mvcc原理"}},[_._v("#")]),_._v(" 4.MVCC原理")]),_._v(" "),t("p",[_._v("MVCC称为多版本并发控制")]),_._v(" "),t("p",[_._v("对于一张表的某条记录")]),_._v(" "),t("p",[_._v("对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数的增多， 所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 "),t("strong",[_._v("版本链")]),_._v(" ，"),t("strong",[_._v("版本链的头节点就是当 前记录最新的值")])]),_._v(" "),t("h4",{attrs:{id:"_1-readview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-readview"}},[_._v("#")]),_._v(" 1).ReadView")]),_._v(" "),t("p",[_._v("MySQL需要判断以下版本连中的哪些版本是当前事务可见的")]),_._v(" "),t("p",[_._v("故MySQL体术一个ReeadView的概念,包括四个内容:")]),_._v(" "),t("ul",[t("li",[_._v("m_ids : 表示在生成 ReadView 时当前系统中活跃的读写事务的 事务id 列表")]),_._v(" "),t("li",[_._v("min_trx_id : 表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务id ，也就是 m_ids 中的最小值")]),_._v(" "),t("li",[_._v("max_trx_id : 表示生成 ReadView 时系统中应该分配给下一个事务的 id 值")]),_._v(" "),t("li",[_._v("creator_trx_id : 表示生成该ReadView的事务的事务id")])]),_._v(" "),t("p",[_._v("根据ReadView,在访问某条记录时,只需要按照下面的步骤判断记录的某个版本是否可见:")]),_._v(" "),t("ul",[t("li",[_._v("如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己 修改过的记录，所以该版本可以被当前事务访问")]),_._v(" "),t("li",[_._v("如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问")]),_._v(" "),t("li",[_._v("如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生 成 ReadView 后才开启，所以该版本不可以被当前事务访问")]),_._v(" "),t("li",[_._v("如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果"),t("strong",[_._v("不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问")])])]),_._v(" "),t("p",[_._v("如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断 可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对 该事务完全不可见，查询结果就不包含该记录")]),_._v(" "),t("h4",{attrs:{id:"_2-生成readview的时机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-生成readview的时机"}},[_._v("#")]),_._v(" 2).生成ReadView的时机")]),_._v(" "),t("p",[_._v("READ COMMITTED --- 每次读取数据前都生成一个ReadView")]),_._v(" "),t("p",[_._v("REPEATABLE READ --- 在第一次读取数据时生成一个ReadView")])])}),[],!1,null,null,null);t.default=a.exports}}]);