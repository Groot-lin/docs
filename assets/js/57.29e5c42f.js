(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{482:function(t,_,v){"use strict";v.r(_);var a=v(2),e=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"一-缓存穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一-缓存穿透"}},[t._v("#")]),t._v(" 一.缓存穿透")]),t._v(" "),_("h3",{attrs:{id:"什么是缓存穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存穿透"}},[t._v("#")]),t._v(" 什么是缓存穿透?")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png",alt:"image-20230524144035560"}})]),t._v(" "),_("p",[t._v("如图,大量客户端请求未命中cache,从而直接请求到数据库中,导致MySQL数据库崩溃")]),t._v(" "),_("p",[t._v("当然，既然使用了缓存，肯定会难免有穿透的发生，正常的少量穿透是对我们业务来说是不会造成任何影响的，因为:")]),t._v(" "),_("ul",[_("li",[t._v("毕竟我们的缓存"),_("strong",[t._v("容量有限")]),t._v("，不可能去缓存所有数据，当面临较大请求时，查询到未被缓存的数据时，就会发生穿透")]),t._v(" "),_("li",[t._v("互联网业务的数据访问模型一般是"),_("strong",[t._v('遵循"二八"原则')]),t._v("的，即 20% 的数据为热点数据，80% 的数据是非热点不被常访问的数据")])]),t._v(" "),_("h3",{attrs:{id:"解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),_("h4",{attrs:{id:"_1-缓存无效的key"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存无效的key"}},[t._v("#")]),t._v(" 1.缓存无效的key")]),t._v(" "),_("p",[t._v("用于解决key变化不频繁,构造一个值为null的key.")]),t._v(" "),_("p",[t._v("但是要给值为null的key设置TTL过期时间")]),t._v(" "),_("p",[t._v("因为这个空值不具有实际业务性，而且还占用空间")]),t._v(" "),_("p",[t._v("在生产应用时要做好监控,防止浪费太多内存")]),t._v(" "),_("h4",{attrs:{id:"_2-布隆过滤器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-布隆过滤器"}},[t._v("#")]),t._v(" 2.布隆过滤器")]),t._v(" "),_("p",[t._v("非常方便的判断一个给定数据是否存在于海量数据之中")]),t._v(" "),_("p",[t._v("具体操作")]),t._v(" "),_("blockquote",[_("p",[t._v("把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。")])]),t._v(" "),_("p",[t._v("布隆过滤器的底层实现是"),_("strong",[t._v("位数组+哈希函数")])]),t._v(" "),_("p",[t._v("位数组很好理解:我只需要判断判断你有没有,不需要判断你具体是什么")]),t._v(" "),_("p",[t._v("要么是0,要么是1")]),t._v(" "),_("p",[t._v("这样就减少了布隆过滤器的占用空间,降低空间成本")]),t._v(" "),_("p",[t._v("布隆过滤器的工作流程:")]),t._v(" "),_("ol",[_("li",[t._v("初始化一个数组,比如长度为1亿")]),t._v(" "),_("li",[t._v("选用一个hash算法,计算得到hash值进行映射")]),t._v(" "),_("li",[t._v("如果索引位置上的值为1的话就是存在,反之不存在")]),t._v(" "),_("li",[t._v("新增信息时,需要更新布隆过滤器")])]),t._v(" "),_("p",[t._v("但是布隆过滤器存在如下弊端:")]),t._v(" "),_("ol",[_("li",[t._v("具有一定概率误判")]),t._v(" "),_("li",[t._v("不具备删除元素的能力")])]),t._v(" "),_("h2",{attrs:{id:"二-缓存击穿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二-缓存击穿"}},[t._v("#")]),t._v(" 二.缓存击穿")]),t._v(" "),_("h3",{attrs:{id:"什么是缓存击穿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存击穿"}},[t._v("#")]),t._v(" 什么是缓存击穿")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png",alt:"image-20230524144724287"}})]),t._v(" "),_("p",[t._v("缓存击穿又叫热点key问题,当大量数据访问key时,但是key过期了")]),t._v(" "),_("p",[t._v("并且这个key的缓存重建比较满")]),t._v(" "),_("p",[t._v("期间大量请求打到数据库中")]),t._v(" "),_("p",[t._v("增加了数据库压力")]),t._v(" "),_("h3",{attrs:{id:"解决方案-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),_("h4",{attrs:{id:"_1-互斥锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-互斥锁"}},[t._v("#")]),t._v(" 1.互斥锁")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E4%BA%92%E6%96%A5%E9%94%81.png",alt:"image.png"}})]),t._v(" "),_("p",[t._v("逻辑如图")]),t._v(" "),_("p",[t._v("线程1先发来请求，并且获取到了互斥锁")]),t._v(" "),_("p",[t._v("这时线程1就可以去查询数据库，接着将查询到的数据缓存到redis中，最后记得释放锁，不然以后别的线程无法访问数据库")]),t._v(" "),_("p",[t._v("如果在线程1获取互斥锁成功并且还未重建缓存、释放互斥锁的时候，线程2的请求到达，那么线程2无法在redis中获取到缓存，无法获取到互斥锁")]),t._v(" "),_("p",[t._v("那么我们就让线程休眠一会，比方休眠50毫秒，再让线程2去查询缓存，如果还是查询不到，那么再重新休眠，再重新查询")]),t._v(" "),_("p",[t._v("这样做的特点是能保证一致性,但是性能会变得很低")]),t._v(" "),_("h4",{attrs:{id:"_2-逻辑过期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-逻辑过期"}},[t._v("#")]),t._v(" 2.逻辑过期")]),t._v(" "),_("p",[t._v("逻辑过期，意味着永不过期")]),t._v(" "),_("p",[t._v("缓存击穿问题产生的原因是某个热点key过期了，请求都打到数据库了，造成数据库压力过大")]),t._v(" "),_("p",[t._v("因此我们可以提前准备一个不过期的热点key "),_("strong",[t._v("（比如参加活动的商品）")]),t._v("，不设置它的过期时间，将这个key保存到redis中，这样理论上总能命中redis")]),t._v(" "),_("blockquote",[_("p",[t._v("那是怎么判断这个key逻辑上过期了？")])]),t._v(" "),_("p",[t._v("答案是这个key的value存储一个过期时间，我们判断这个key是否过期的依据，就是这个key的value保存的过期时间")]),t._v(" "),_("h4",{attrs:{id:"_3-定时任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-定时任务"}},[t._v("#")]),t._v(" 3.定时任务")]),t._v(" "),_("p",[t._v("使用定时任务,专门主动更新即将过期的数据")]),t._v(" "),_("p",[t._v("比如开发设置jay这个热点key的时候，同时设置了过期时间为60分钟")]),t._v(" "),_("p",[t._v("那后台程序在第55分钟的时候，会去数据库查询数据并重新放到缓存中，同时再次设置缓存为60分钟")]),t._v(" "),_("h2",{attrs:{id:"三-缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三-缓存雪崩"}},[t._v("#")]),t._v(" 三.缓存雪崩")]),t._v(" "),_("h3",{attrs:{id:"什么是缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存雪崩"}},[t._v("#")]),t._v(" 什么是缓存雪崩?")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png",alt:"image-20230524145437545"}})]),t._v(" "),_("p",[t._v("缓存雪崩是指缓存中"),_("strong",[t._v("大多数的数据")]),t._v("在同一时间到达过期时间，而查询数据量巨大")]),t._v(" "),_("p",[t._v("这时候，又是"),_("strong",[t._v("缓存中没有，数据库中有")]),t._v("的情况了")]),t._v(" "),_("p",[t._v("请求都打到数据库上，引起数据库流量激增，压力瞬间增大，直接崩溃")]),t._v(" "),_("h3",{attrs:{id:"解决方案-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-3"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),_("h4",{attrs:{id:"_1-互斥锁-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-互斥锁-2"}},[t._v("#")]),t._v(" 1.互斥锁")]),t._v(" "),_("p",[t._v("雪崩和击穿是多个和一个的区别")]),t._v(" "),_("p",[t._v("那我多加几个互斥锁不就得了?")]),t._v(" "),_("h4",{attrs:{id:"_2-错峰过期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-错峰过期"}},[t._v("#")]),t._v(" 2. 错峰过期")]),t._v(" "),_("p",[t._v("系统大范围重建缓存")]),t._v(" "),_("p",[t._v("在设置key的过期时间时")]),t._v(" "),_("p",[t._v("可以加上一个短的随机函数")]),t._v(" "),_("p",[t._v("就能避免大量缓存在同一时间失效")]),t._v(" "),_("h4",{attrs:{id:"_3-缓存集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-缓存集群"}},[t._v("#")]),t._v(" 3. 缓存集群")]),t._v(" "),_("p",[t._v("部署Redis集群,提高服务可用性")]),t._v(" "),_("h4",{attrs:{id:"_4-限流器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-限流器"}},[t._v("#")]),t._v(" 4.限流器")]),t._v(" "),_("p",[t._v("引入限流器")]),t._v(" "),_("p",[t._v("假设你的限流器设置的一秒钟最多5千个请求，那么这个时候来了8千个请求")]),t._v(" "),_("p",[t._v("多出来的3000个就走降级流程，对用户进行友好提示")]),t._v(" "),_("p",[t._v("帮助数据库减轻压力,挺过难关")]),t._v(" "),_("h2",{attrs:{id:"四-redis淘汰策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四-redis淘汰策略"}},[t._v("#")]),t._v(" 四.Redis淘汰策略")]),t._v(" "),_("p",[t._v("先思考一个问题:")]),t._v(" "),_("blockquote",[_("p",[t._v("Redis数据库内存满了,此时新插入一个键值对会怎么样?")])]),t._v(" "),_("p",[t._v("答:使用"),_("strong",[t._v("LRU算法")]),t._v("将最久未被访问的键值删除")]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("所谓数据淘汰是指在Redis内存使用达到一定阈值的时候，执行某种策略释放内存空间，以便于接收新的数据")]),t._v(" "),_("p",[t._v("淘汰策略配置"),_("code",[t._v("maxmemory-policy")]),t._v("，表示当内存达到"),_("code",[t._v("maxmemory")]),t._v("时，将执行配置的淘汰策略")]),t._v(" "),_("h3",{attrs:{id:"_1-淘汰策略的选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-淘汰策略的选择"}},[t._v("#")]),t._v(" 1.淘汰策略的选择")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("淘汰策略")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("noeviction")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("当内存使用超过配置的时候会返回错误，不会驱逐任何键")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("allkeys-lru")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("volatile-lru")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("allkeys-random")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("加入键的时候如果过限，从所有key随机删除")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("volatile-random")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("加入键的时候如果过限，从过期键的集合中随机驱逐")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("volatile-ttl")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("从配置了过期时间的键中驱逐马上就要过期的键")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("volatile-lfu")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("从所有配置了过期时间的键中驱逐使用频率最少的键")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("allkeys-lfu")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("从所有键中驱逐使用频率最少的键")])])])]),t._v(" "),_("h2",{attrs:{id:"五-redis过期删除策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五-redis过期删除策略"}},[t._v("#")]),t._v(" 五.Redis过期删除策略")]),t._v(" "),_("p",[t._v("说这个之前,我们先来了解一下"),_("strong",[t._v("TTL")]),t._v("的原理")]),t._v(" "),_("p",[t._v("确定一个键是否过期:")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("检查这个键是否在过期字典中,如果存在就去除这个键的过期时间("),_("strong",[t._v("过期字典存储的是每个键的过期时间，字典中 key 是 键， value 是 long 类型的过期时间")]),t._v(")")])]),t._v(" "),_("li",[_("p",[t._v("拿到过期时间之后,和当前UNIX时间戳比较,如果大于当前时间戳则键过期")])])]),t._v(" "),_("p",[t._v("判断一个键是否过期以后,接下来我们来说一下三种删除策略:")]),t._v(" "),_("h3",{attrs:{id:"_1-定时删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-定时删除"}},[t._v("#")]),t._v(" 1.定时删除")]),t._v(" "),_("p",[t._v("在设置键的过期时间时，创建一个定时器，当到达键过期时间时通过定时器去删除键")]),t._v(" "),_("p",[_("strong",[t._v("优点")]),t._v("是对内存友好,一旦过期就删除")]),t._v(" "),_("p",[_("strong",[t._v("缺点")]),t._v("是对定时任务比较占用CPU资源")]),t._v(" "),_("h3",{attrs:{id:"_2-惰性删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-惰性删除"}},[t._v("#")]),t._v(" 2.惰性删除")]),t._v(" "),_("p",[t._v("惰性删除并不是当到达过期时间时去删除")]),t._v(" "),_("p",[t._v("而是每次获取键时，会判断是否过期，如果过期则删除，并返回空")]),t._v(" "),_("p",[t._v("没过期，就返回键值")]),t._v(" "),_("p",[t._v("此时优缺点和定时删除相反:")]),t._v(" "),_("p",[_("strong",[t._v("优点")]),t._v("是对CPU友好,过期键不花费CPU处理")]),t._v(" "),_("p",[_("strong",[t._v("缺点")]),t._v("是对内存不友好,有些键不删除会一直占用内存")]),t._v(" "),_("h3",{attrs:{id:"_3-定期删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-定期删除"}},[t._v("#")]),t._v(" 3.定期删除")]),t._v(" "),_("p",[t._v("Redis提供了一种折中的方法:")]),t._v(" "),_("ul",[_("li",[t._v("定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响")]),t._v(" "),_("li",[t._v("并且，通过定期删除过期键，有效的减少了过期键带来的内存浪费")])]),t._v(" "),_("p",[t._v("用定期删除策略的话需要通过具体的业务场景来定义时长和频率")]),t._v(" "),_("p",[_("u",[_("strong",[t._v("Redis采用的是惰性删除+定期删除的策略")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);