(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{474:function(s,a,t){"use strict";t.r(a);var _=t(2),r=Object(_.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"一-什么是索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-什么是索引"}},[s._v("#")]),s._v(" 一.什么是索引")]),s._v(" "),a("p",[s._v("相当于一本书的目录")]),s._v(" "),a("p",[s._v("索引是用某种算法,构建出一个数据模型,用于快速找出某些数据")]),s._v(" "),a("p",[s._v("如果没有索引,mysql就必须使用全表扫描的方式,会降低效率")]),s._v(" "),a("p",[s._v("由于数据页的编号可能并不是连续的")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E6%95%B0%E6%8D%AE%E9%A1%B5.png",alt:"image-20231004154838378"}})]),s._v(" "),a("p",[s._v("我们需要给他们做一个目录,其中每个页对应着一个目录项")]),s._v(" "),a("p",[s._v("每个目录项包括:")]),s._v(" "),a("ul",[a("li",[s._v("页的用户记录中最小的主键值,使用key来表示")]),s._v(" "),a("li",[s._v("页号,我们使用page_no表示")])]),s._v(" "),a("p",[s._v("比如")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9B%AE%E5%BD%95.png",alt:"image-20231004155040435"}})]),s._v(" "),a("h2",{attrs:{id:"二-索引方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-索引方案"}},[s._v("#")]),s._v(" 二.索引方案")]),s._v(" "),a("p",[s._v("上边简易索引方案所带来的问题:")]),s._v(" "),a("ul",[a("li",[s._v("InnoDB使用页来作为管理存储空间的基本单位,也就是保证16kb的连续存储空间,随着表中记录的则更多,需要非常大的连续的存储空间才能把所有的目录项都放下")]),s._v(" "),a("li",[s._v("我们时常会对记录进行增删，假设我们把 页28 中的记录都删除了， 页28 也就没有存在的必要了，那意味 着 目录项2 也就没有存在的必要了，这就需要把 目录项2 后的目录项都向前移动一下,会增加不少成本")])]),s._v(" "),a("h3",{attrs:{id:"_1-mysql的索引方案-b-树索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql的索引方案-b-树索引"}},[s._v("#")]),s._v(" 1.MySQL的索引方案-B+树索引")]),s._v(" "),a("p",[s._v("MySQL复用了之前存储记录的数据页来存储目录项,把这些表示目录项的记录称为"),a("strong",[s._v("目录项记录")])]),s._v(" "),a("p",[a("strong",[s._v("如何区分一条记录是目录项记录还是数用户记录?")])]),s._v(" "),a("ol",[a("li",[s._v("行格式中,记录头信息中的record_type属性:")])]),s._v(" "),a("ul",[a("li",[s._v("0 : 普通的用户记录")]),s._v(" "),a("li",[s._v("1 : 目录项记录")]),s._v(" "),a("li",[s._v("2 : 最小记录")]),s._v(" "),a("li",[s._v("3 : 最大记录")])]),s._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[s._v("min_rec_mask属性,在目录项记录中值为1,其他为0")])]),s._v(" "),a("p",[a("strong",[s._v("如果目录项记录页太多了怎么办?")])]),s._v(" "),a("p",[s._v("在创建一个目录项页用来指向这些目录页,相当于书架和图书的关系,以此类推")]),s._v(" "),a("p",[s._v("这就是B+树索引")]),s._v(" "),a("h3",{attrs:{id:"_2-聚簇索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-聚簇索引"}},[s._v("#")]),s._v(" 2.聚簇索引")]),s._v(" "),a("p",[s._v("B+树索引有两个特点:")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("使用记录主键值的大小进行记录和页的排序,包括")]),s._v(" "),a("ul",[a("li",[s._v("页内的记录是按照主键的大小顺序排成一个单向链表")]),s._v(" "),a("li",[s._v("各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表")]),s._v(" "),a("li",[s._v("存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成 一个双向链表")])])]),s._v(" "),a("li",[a("p",[s._v("B+树的叶子节点存储的是完整的用户记录(指这个记录存储了所有列的值(包括隐藏列))")])])]),s._v(" "),a("p",[s._v("我们把具有这两种特性的 B+ 树称为 "),a("strong",[s._v("聚簇索引")]),s._v(",所有完整的用户记录都存放在这个 聚簇索引 的叶子节点处")]),s._v(" "),a("p",[s._v("InnoDB 存储引擎会自动的为我们创建聚簇索引")]),s._v(" "),a("h3",{attrs:{id:"_3-二级索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-二级索引"}},[s._v("#")]),s._v(" 3.二级索引")]),s._v(" "),a("p",[s._v("聚簇索引 只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的")]),s._v(" "),a("p",[s._v("如果想以非主键列作为搜索条件,可以新建B+树,不同的B+树采用不同的排序规则")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png",alt:"image-20231004162107610"}})]),s._v(" "),a("p",[s._v("如图")]),s._v(" "),a("p",[s._v("假设我们想找一个c2列值为4的记录")]),s._v(" "),a("ol",[a("li",[s._v("确定目录项记录页到页44")]),s._v(" "),a("li",[s._v("定位到目录项记录页42(2<4<9)")]),s._v(" "),a("li",[s._v("定位到页34和页35")]),s._v(" "),a("li",[s._v("但是该B+树叶子节点中的记录只存储了c2 和 c1 （也就是 主键 ）两个列，所以我们必须"),a("strong",[s._v("再根据主键值去聚簇索引中再查找一遍完整的用户记录")])])]),s._v(" "),a("p",[s._v("以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到 聚簇索引中再查一遍")]),s._v(" "),a("p",[s._v("这称为"),a("strong",[s._v("回表")])]),s._v(" "),a("p",[a("strong",[s._v("为什么不把完整的用户记录放到该B+树的叶子节点呢?")])]),s._v(" "),a("p",[s._v("会造成存储空间的浪费,这种B+树被称为二级索引")]),s._v(" "),a("h3",{attrs:{id:"_4-联合索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-联合索引"}},[s._v("#")]),s._v(" 4.联合索引")]),s._v(" "),a("p",[s._v("可以同时以多个列的大小作为排序规则称为联合索引")]),s._v(" "),a("h3",{attrs:{id:"_5-根页面的不动性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-根页面的不动性"}},[s._v("#")]),s._v(" 5.根页面的不动性")]),s._v(" "),a("p",[s._v("一个B+树索引的"),a("strong",[s._v("根节点自诞生之日起，便不会再移动")])]),s._v(" "),a("p",[s._v("这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方")]),s._v(" "),a("p",[s._v("然后凡是 InnoDB 存储引擎需要用到这个索引的 时候，都会从那个固定的地方取出 根节点 的页号，从而来访问这个索引")]),s._v(" "),a("h2",{attrs:{id:"三-索引的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-索引的使用"}},[s._v("#")]),s._v(" 三.索引的使用")]),s._v(" "),a("h3",{attrs:{id:"_1-索引的代价"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引的代价"}},[s._v("#")]),s._v(" 1.索引的代价")]),s._v(" "),a("ol",[a("li",[s._v("空间上的代价")])]),s._v(" "),a("p",[s._v("每建立一个索引都为它建立一颗B+树,b+树的每一个节点都是一个数据页")]),s._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[s._v("空间上的代价")])]),s._v(" "),a("p",[s._v("每次对表中数据进行增删改查的时候都会去修改各个b+树从而导致时间成本上的增加")]),s._v(" "),a("h3",{attrs:{id:"_2-b-树索引适用的条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-b-树索引适用的条件"}},[s._v("#")]),s._v(" 2.B+树索引适用的条件")]),s._v(" "),a("p",[s._v("首先建立一张表")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("CREATE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLE")]),s._v(" person_info"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("\n id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("INT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("NOT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("auto_increment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("NOT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n birthday "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("DATE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("NOT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n phone_number "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("CHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("11")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("NOT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n country "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("NOT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("PRIMARY")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("KEY")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("KEY")]),s._v(" idx_name_birthday_phone_number "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" birthday"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" phone_number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("主键id")]),s._v(" "),a("p",[s._v("二级索引 idx_name_birthday_phone_number,排序方式为先排序name,再按birthday排序,最后按phone_number排")]),s._v(" "),a("h4",{attrs:{id:"_1-全值匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-全值匹配"}},[s._v("#")]),s._v(" 1).全值匹配")]),s._v(" "),a("p",[s._v("如果我们的"),a("strong",[s._v("搜索条件中的列和索引列一致")]),s._v(",则称为全值匹配")]),s._v(" "),a("p",[s._v("如:")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" person_info \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" \nname "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Ashburn'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" \nbirthday "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'1990-09-27'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" \nphone_number "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'15123983239'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("查询过程如下")]),s._v(" "),a("ul",[a("li",[s._v("因为 B+ 树的数据页和记录先是按照 name 列的值进行排序的，所以先可以很快定位 name 列的值是 Ashburn 的记录位置")]),s._v(" "),a("li",[s._v("在 name 列相同的记录里又是按照 birthday 列的值进行排序的，所以在 name 列的值是 Ashburn 的记录里又 可以快速定位 birthday 列的值是 '1990-09-27' 的记录")]),s._v(" "),a("li",[s._v("如果很不幸，name 和 birthday 列的值都是相同的，那记录是按照 phone_number 列的值排序的，所以联合 索引中的三个列都可能被用到")])]),s._v(" "),a("p",[s._v("如果交换了查询顺序,查询效率无影响---查询优化器")]),s._v(" "),a("h4",{attrs:{id:"_2-匹配左边的列-最左匹配原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-匹配左边的列-最左匹配原则"}},[s._v("#")]),s._v(" 2).匹配左边的列-最左匹配原则")]),s._v(" "),a("p",[s._v("其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" person_info "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Ashburn'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("如果使用以下查询结果")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" person_info "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" birthday "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'1990-09-27'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("将用不到B+树索引")]),s._v(" "),a("p",[s._v("因为 B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使 用 birthday 列进行排序，也就是说 name 列的值不同的记录中 birthday 的值可能是无序的。而现在你跳过 name 列直接根据 birthday 的值去查找将无法查找到")]),s._v(" "),a("p",[a("strong",[s._v("如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中 从最左边连续的列")])]),s._v(" "),a("h4",{attrs:{id:"_3-匹配列前缀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-匹配列前缀"}},[s._v("#")]),s._v(" 3).匹配列前缀")]),s._v(" "),a("p",[a("strong",[s._v("为某个列建立索引的意思其实就是在对应的 B+ 树的记录中使用该列的值进行排序")])]),s._v(" "),a("p",[s._v("字符串的排序规则使前缀都是排好序的")]),s._v(" "),a("p",[s._v("所以对于字符串类型的索引列来说，我们只匹配 它的前缀也是可以快速定位记录的，比方说我们想查询名字以 'As' 开头的记录，那就可以这么写查询语句：")]),s._v(" "),a("div",{staticClass:"language-sql\\ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("SELECT * FROM person_info WHERE name LIKE 'As%'\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h4",{attrs:{id:"_4-匹配范围值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-匹配范围值"}},[s._v("#")]),s._v(" 4).匹配范围值")]),s._v(" "),a("h3",{attrs:{id:"_3-回表的代价"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-回表的代价"}},[s._v("#")]),s._v(" 3.回表的代价")]),s._v(" "),a("p",[s._v("看下边这个查询：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" person_info "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Asa'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("AND")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Barlow'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("在使用 idx_name_birthday_phone_number 索引进行查询时大致可以分为这两个步骤：")]),s._v(" "),a("ol",[a("li",[s._v("从索引 idx_name_birthday_phone_number 对应的 B+ 树中取出 name 值在 Asa ～ Barlow 之间的用户记录")]),s._v(" "),a("li",[s._v("由于索引 idx_name_birthday_phone_number 对应的 B+ 树用户记录中只包含 name 、 birthday 、 phone_number 、 id 这4个字段，而查询列表是 * ，意味着要查询表中所有字段，也就是还要包括 country 字段。这时需要把从上一步中获取到的每一条记录的 id 字段都到聚簇索引对应的 B+ 树中找到完整的用户记录，也就是我们通常所说的 "),a("strong",[s._v("回表")]),s._v(" ，然后把完整的用户记录返回给查询用户")])]),s._v(" "),a("p",[s._v("由于索引 idx_name_birthday_phone_number 对应的 B+ 树中的记录首先会按照 name 列的值进行排序，所以值 在 Asa ～ Barlow 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这 些连着的记录从磁盘中读出来，这种读取方式我们也可以称为 "),a("strong",[s._v("顺序I/O")])]),s._v(" "),a("p",[s._v("根据第1步中获取到的记录的 id 字段 的值可能并不相连，而在聚簇索引中记录是根据 id （也就是主键）的顺序排列的，所以根据这些并不连续的 id 值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数 据页，这种读取方式我们也可以称为 "),a("strong",[s._v("随机I/O")])]),s._v(" "),a("p",[s._v("一般情况下，"),a("strong",[s._v("顺序I/O比随机I/O的性能高很多")]),s._v("，所以步骤1的执行 可能很快，而步骤2就慢一些。所以这个使用索引 idx_name_birthday_phone_number 的查询有这么两个特点：")]),s._v(" "),a("ul",[a("li",[s._v("会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引")]),s._v(" "),a("li",[s._v("访问二级索引使用 顺序I/O ，访问聚簇索引使用 随机I/O")])]),s._v(" "),a("p",[a("strong",[s._v("需要回表的记录越多，使用二级索引的性能就越低")]),s._v("，甚至让某些查询宁愿使用全表扫描也不使用 二级索引")]),s._v(" "),a("p",[a("strong",[s._v("那什么时候采用全表扫描的方式，什么时候使用采用 二级索引 + 回表 的方式去执行查询呢？")])]),s._v(" "),a("p",[s._v("需要使用查询优化器来工作")]),s._v(" "),a("p",[s._v("查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的 条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索 引 + 回表 的方式")]),s._v(" "),a("p",[s._v("sql调优建议:")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("为了告别回表所带来的性能损耗,我们建议"),a("u",[a("strong",[s._v("最好在查询列表里只包含索引列")])])])]),s._v(" "),a("li",[a("p",[s._v("我们很不鼓励用 * 号作为查询列表，最好把我们需要查询的列依次标明")])])]),s._v(" "),a("h3",{attrs:{id:"_4-如何挑选索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何挑选索引"}},[s._v("#")]),s._v(" 4.如何挑选索引")]),s._v(" "),a("h4",{attrs:{id:"_1-只为用于搜索、排序或分组的列创建索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-只为用于搜索、排序或分组的列创建索引"}},[s._v("#")]),s._v(" 1).只为用于搜索、排序或分组的列创建索引")]),s._v(" "),a("p",[s._v("也就是说，"),a("strong",[s._v("只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的 列创建索引")]),s._v(",而出现在查询列表中的列就没必要建立索引了")]),s._v(" "),a("h4",{attrs:{id:"_2-考虑列的基数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-考虑列的基数"}},[s._v("#")]),s._v(" 2).考虑列的基数")]),s._v(" "),a("p",[s._v("列的基数 指的是某一列中不重复数据的个数，比方说某个列包含值 2, 5, 8, 2, 5, 8, 2, 5, 8 ，虽然有 9 条 记录，但该列的基数却是 3 。")]),s._v(" "),a("p",[s._v("在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中")]),s._v(" "),a("p",[s._v("基数越小越难进行排序")]),s._v(" "),a("p",[a("strong",[s._v("最好为那些列的基数大的列建立索引，为基数 太小列的建立索引效果可能不好")])]),s._v(" "),a("h4",{attrs:{id:"_3-索引列的类型尽量小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-索引列的类型尽量小"}},[s._v("#")]),s._v(" 3).索引列的类型尽量小")]),s._v(" "),a("p",[s._v("类型大小指该类型表示的数据范围的大小")]),s._v(" "),a("p",[s._v("如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况 下，"),a("strong",[s._v("尽量让索引列使用较小的类型")]),s._v("，比如我们能使用 INT 就不要使用 BIGINT ，能使用 MEDIUMINT 就不要使用 INT")]),s._v(" "),a("p",[s._v("因为:")]),s._v(" "),a("ul",[a("li",[s._v("数据类型越小,在查询时进行的比较操作越快")]),s._v(" "),a("li",[s._v("数据类型越小,索引占用的存储空间就越少,在一个数据页内就能放下更多东西,从而减少I/O的速度")])]),s._v(" "),a("h4",{attrs:{id:"_4-索引字符串值的前缀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-索引字符串值的前缀"}},[s._v("#")]),s._v(" 4).索引字符串值的前缀")]),s._v(" "),a("p",[s._v("索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 --- "),a("strong",[s._v("只对字符串的前几 个字符进行索引")]),s._v("也就是说在二级索引的记录中只保留字符串前几个字符。")]),s._v(" "),a("p",[s._v("这样只在 B+ 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题")])])}),[],!1,null,null,null);a.default=r.exports}}]);