(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{491:function(a,v,_){"use strict";_.r(v);var t=_(2),s=Object(t.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("p",[a._v("以JDK1.8为例")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png",alt:"Java 运行时数据区域（JDK1.8 ）"}})]),a._v(" "),v("p",[v("strong",[a._v("线程私有的")]),a._v(":")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("程序计数器")])]),a._v(" "),v("li",[v("p",[a._v("虚拟机栈")])]),a._v(" "),v("li",[v("p",[a._v("本地方法栈")])])]),a._v(" "),v("p",[v("strong",[a._v("线程共享的")]),a._v(":")]),a._v(" "),v("ul",[v("li",[a._v("堆")]),a._v(" "),v("li",[a._v("方法区")]),a._v(" "),v("li",[a._v("直接内存")])]),a._v(" "),v("h2",{attrs:{id:"一-线程私有"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一-线程私有"}},[a._v("#")]),a._v(" 一.线程私有")]),a._v(" "),v("h3",{attrs:{id:"_1-程序计数器-pc-register"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-程序计数器-pc-register"}},[a._v("#")]),a._v(" 1.程序计数器 PC Register")]),a._v(" "),v("p",[a._v("程序计数器会随着线程的启动而创建")]),a._v(" "),v("p",[a._v("用来存放"),v("strong",[a._v("下一条")]),a._v("JVM指令的执行地址")]),a._v(" "),v("p",[a._v("物理上使用"),v("strong",[a._v("寄存器")]),a._v("来实现")]),a._v(" "),v("p",[a._v("特点:")]),a._v(" "),v("ul",[v("li",[a._v("线程私有")]),a._v(" "),v("li",[a._v("不会存在内存溢出")])]),a._v(" "),v("h3",{attrs:{id:"_2-java虚拟机栈-jvm-stacks"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-java虚拟机栈-jvm-stacks"}},[a._v("#")]),a._v(" 2.Java虚拟机栈-JVM Stacks")]),a._v(" "),v("h4",{attrs:{id:"虚拟机栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[a._v("#")]),a._v(" 虚拟机栈")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("每个线程运行时所需要的内存称为"),v("strong",[a._v("虚拟机栈")])])]),a._v(" "),v("li",[v("p",[a._v("栈由一个个"),v("strong",[a._v("栈帧")]),a._v("("),v("strong",[a._v("每个方法运行需要的内存")]),a._v(")组成")])]),a._v(" "),v("li",[v("p",[a._v("每个线程只能友一个活动栈帧,对应当前正在执行的那个方法")])])]),a._v(" "),v("h4",{attrs:{id:"栈帧包括"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈帧包括"}},[a._v("#")]),a._v(" 栈帧包括 :")]),a._v(" "),v("ul",[v("li",[a._v("局部变量表")]),a._v(" "),v("li",[a._v("操作数栈")]),a._v(" "),v("li",[a._v("动态链接")]),a._v(" "),v("li",[a._v("方法返回地址")])]),a._v(" "),v("p",[v("img",{attrs:{src:"https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png",alt:"Java 虚拟机栈"}})]),a._v(" "),v("h4",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[a._v("#")]),a._v(" 问题 :")]),a._v(" "),v("ul",[v("li",[a._v("垃圾回收涉不涉及刀栈内存?\n"),v("ul",[v("li",[a._v("不涉及")])])]),a._v(" "),v("li",[a._v("栈内存设置越大程序跑得越快吗?\n"),v("ul",[v("li",[a._v("不是,内存总大小一定,栈内存越大,线程数越少")])])]),a._v(" "),v("li",[a._v("方法内的局部变量是否线程安全\n"),v("ul",[v("li",[a._v("局部变脸线程私有,不会受到其他线程干扰,除非时被"),v("strong",[a._v("static")]),a._v("修饰,如果局部变量引用了对象,并逃离方法的作用范围,需要考虑线程安全")])])])]),a._v(" "),v("h4",{attrs:{id:"栈内存溢出-java-lang-stackoverflowerror"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈内存溢出-java-lang-stackoverflowerror"}},[a._v("#")]),a._v(" 栈内存溢出-java.lang.StackOverflowError")]),a._v(" "),v("p",[a._v("修改参数"),v("code",[a._v("-Xss 1m")])]),a._v(" "),v("ol",[v("li",[a._v("栈帧过多导致内存溢出(如递归未设置终止条件导致溢出)")]),a._v(" "),v("li",[a._v("栈帧过大直接导致超过栈大小导致溢出(可能性较小)")])]),a._v(" "),v("h3",{attrs:{id:"_3-本地方法栈-native-method-stacks"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-本地方法栈-native-method-stacks"}},[a._v("#")]),a._v(" 3.本地方法栈-Native Method Stacks")]),a._v(" "),v("p",[a._v("Java虚拟机调用本地方法时的运行内存空间")]),a._v(" "),v("p",[a._v("虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务")]),a._v(" "),v("p",[a._v("而本地方法栈则为虚拟机使用到的 "),v("strong",[a._v("Native 方法")]),a._v("服务")]),a._v(" "),v("p",[a._v("其结构与虚拟机栈类似")]),a._v(" "),v("h2",{attrs:{id:"二-线程共有"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-线程共有"}},[a._v("#")]),a._v(" 二.线程共有")]),a._v(" "),v("h3",{attrs:{id:"_1-堆-heap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-堆-heap"}},[a._v("#")]),a._v(" 1.堆-Heap")]),a._v(" "),v("h4",{attrs:{id:"堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),v("p",[a._v("Java虚拟机所管理的内存中最大的一块")]),a._v(" "),v("p",[a._v("Java堆是所有线程共享的的一块内存区域")]),a._v(" "),v("p",[a._v("在虚拟机启动时创建")]),a._v(" "),v("h4",{attrs:{id:"作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[a._v("#")]),a._v(" "),v("strong",[a._v("作用")]),a._v(":")]),a._v(" "),v("p",[a._v("存放对象实例")]),a._v(" "),v("p",[a._v("使用"),v("strong",[a._v("new")]),a._v("关键字创建的")]),a._v(" "),v("h4",{attrs:{id:"堆内存溢出-outofmemoryerror"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆内存溢出-outofmemoryerror"}},[a._v("#")]),a._v(" 堆内存溢出-OutOfMemoryError")]),a._v(" "),v("p",[a._v("修改参数"),v("code",[a._v("-Xmx 8m")])]),a._v(" "),v("p",[a._v("命令 :")]),a._v(" "),v("p",[a._v("Terminal-local里面的命令行")]),a._v(" "),v("ul",[v("li",[a._v("jps : 获取当前正在运行的进程及id")]),a._v(" "),v("li",[a._v("jmap -heap xxxxx : 检查进程堆内存占用情况")])]),a._v(" "),v("h3",{attrs:{id:"_2-方法区-method-area"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-方法区-method-area"}},[a._v("#")]),a._v(" 2.方法区 Method Area")]),a._v(" "),v("p",[a._v("方法区在JVM启动时创建")]),a._v(" "),v("p",[a._v("方法区是JVM运行时数据区域的一块逻辑区域")]),a._v(" "),v("p",[a._v("方法区会存储已被虚拟机加载的 "),v("strong",[a._v("类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据")]),a._v("。")]),a._v(" "),v("h4",{attrs:{id:"jdk1-8以前"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8以前"}},[a._v("#")]),a._v(" JDK1.8以前")]),a._v(" "),v("p",[a._v("方法区在线程共享中")]),a._v(" "),v("p",[a._v("设置最大内存"),v("code",[a._v("-XX:MaxPermSize=8m")])]),a._v(" "),v("p",[a._v("内存溢出报错")]),a._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[v("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("OutOfMemoryError")]),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PermGen")]),a._v(" space\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("h4",{attrs:{id:"jdk1-8"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8"}},[a._v("#")]),a._v(" JDK1.8")]),a._v(" "),v("p",[a._v("JDK1.8以后方法区改名"),v("big",[v("strong",[a._v("元空间")])]),a._v("放在本地内存中")],1),a._v(" "),v("p",[a._v("设置最大内存"),v("code",[a._v("-XX:MaxMetaspaceSize=8m")])]),a._v(" "),v("h2",{attrs:{id:"三-本地内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三-本地内存"}},[a._v("#")]),a._v(" 三.本地内存")]),a._v(" "),v("p",[a._v("以上是运行时数据区域")]),a._v(" "),v("p",[a._v("下面是本地内存")]),a._v(" "),v("h3",{attrs:{id:"运行时常量池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[a._v("#")]),a._v(" 运行时常量池")]),a._v(" "),v("p",[a._v("存放在"),v("strong",[a._v("方法区")]),a._v("中")]),a._v(" "),v("p",[a._v("包括")]),a._v(" "),v("ul",[v("li",[a._v("字面量 : 源代码中的固定值表示法,即通过字面我们就能知道其值的含义(整数,浮点数,字符串等)")]),a._v(" "),v("li",[a._v("常量池表,虚拟机指令根据这张常量表找到要执行的"),v("strong",[a._v("类名")]),a._v(","),v("strong",[a._v("方法名")]),a._v(","),v("strong",[a._v("参数类型")]),a._v(","),v("strong",[a._v("字面量")]),a._v("等信息")])]),a._v(" "),v("p",[a._v("当某类被加载,它的"),v("strong",[a._v("常量池信息")]),a._v("就会放入"),v("strong",[a._v("运行时常量池")]),a._v(",并把里面的符号地址变为"),v("strong",[a._v("真实地址")])]),a._v(" "),v("h3",{attrs:{id:"字符串常量池-stringtable"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池-stringtable"}},[a._v("#")]),a._v(" 字符串常量池-StringTable")]),a._v(" "),v("p",[a._v("字符串常量池是JVM为为了提升性能和减少内存消耗,正对字符串(String 类)专门开辟的一块区域")]),a._v(" "),v("p",[a._v("主要目的是避免字符串的重复创建")]),a._v(" "),v("p",[a._v("例：")]),a._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" str "),v("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[a._v('"abc"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("ol",[v("li",[a._v('将字符串对象"abc"的引用保存在字符串常量池中')]),a._v(" "),v("li",[a._v('直接返回字符串常量池中的字符串对象"ab"的引用')])]),a._v(" "),v("h3",{attrs:{id:"直接内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[a._v("#")]),a._v(" 直接内存")]),a._v(" "),v("p",[a._v("一种特殊的内存缓冲区,属于"),v("big",[v("strong",[a._v("操作系统内存")])])],1),a._v(" "),v("p",[a._v("磁盘文件可以读到直接内存")]),a._v(" "),v("p",[a._v("Java堆内存也可也直接访问")]),a._v(" "),v("p",[a._v("减少了一次缓冲操作")])])}),[],!1,null,null,null);v.default=s.exports}}]);