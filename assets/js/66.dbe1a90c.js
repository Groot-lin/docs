(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{492:function(t,a,s){"use strict";s.r(a);var e=s(2),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一-如何判断对象是否可以回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-如何判断对象是否可以回收"}},[t._v("#")]),t._v(" 一.如何判断对象是否可以回收")]),t._v(" "),a("h3",{attrs:{id:"_1-引用计数法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数法"}},[t._v("#")]),t._v(" 1.引用计数法")]),t._v(" "),a("p",[t._v("如果一个对象被引用,则计数器+1")]),t._v(" "),a("p",[t._v("当引用失效时，引用计数器就减1")]),t._v(" "),a("p",[t._v("当对象计数器为0时,回收对象")]),t._v(" "),a("p",[t._v("但是如果")]),t._v(" "),a("p",[t._v("两个对象相互循环引用,则无法被回收")]),t._v(" "),a("h3",{attrs:{id:"_2-可达性分析算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-可达性分析算法"}},[t._v("#")]),t._v(" 2.可达性分析算法")]),t._v(" "),a("p",[t._v("JVM 中的"),a("strong",[t._v("垃圾回收器")]),t._v("采用可达性分析来探索所有存活的对象")]),t._v(" "),a("p",[t._v("在堆中进行扫描")]),t._v(" "),a("p",[t._v("看看是否能沿着GC Root对象为起点的引用链找到该对象")]),t._v(" "),a("p",[t._v("如果一个对象没有被根对象直接或间接引用,那就可以被当成垃圾回收")]),t._v(" "),a("p",[t._v("哪些类可以作为GC Root对象?")]),t._v(" "),a("ul",[a("li",[t._v("System Class 如 Object,HashMap,System,String等")]),t._v(" "),a("li",[t._v("Native Stack 操作系统方法")]),t._v(" "),a("li",[t._v("Thread 活动线程对象")]),t._v(" "),a("li",[t._v("Busy Monitor 被加锁的对象不会被回收")])]),t._v(" "),a("h2",{attrs:{id:"二-jvm-引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-jvm-引用"}},[t._v("#")]),t._v(" 二.JVM 引用")]),t._v(" "),a("p",[t._v("软弱虚引用本身是一个对象")]),t._v(" "),a("h3",{attrs:{id:"_1-强引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-强引用"}},[t._v("#")]),t._v(" 1.强引用")]),t._v(" "),a("p",[t._v("最普遍的引用大部分引用都是强引用")]),t._v(" "),a("p",[t._v("如")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" object "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("JVM不会回收此类对象")]),t._v(" "),a("p",[t._v("如果想清理内存,可以将该值设为null")]),t._v(" "),a("h3",{attrs:{id:"_2-软引用-softreference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-软引用-softreference"}},[t._v("#")]),t._v(" 2.软引用 SoftReference")]),t._v(" "),a("p",[t._v("对象A --\x3e 软引用 --\x3e 对象B")]),t._v(" "),a("p",[t._v("软引用是用来描述一些"),a("strong",[t._v("有用但并不是必需")]),t._v("的对象")]),t._v(" "),a("p",[t._v("只有在"),a("strong",[t._v("内存不足")]),t._v("且"),a("strong",[t._v("进行垃圾回收")]),t._v("的时候JVM才会回收该对象")]),t._v(" "),a("p",[t._v("可以应用在网页缓存,图片缓存上")]),t._v(" "),a("p",[t._v("清理软引用")]),t._v(" "),a("p",[t._v("关联引用队列,当软引用所关联的对象被回收时,软引用本身会加入到queue中")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceQueue")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" queue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReferenceQueue")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"_3-弱引用-softreference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-弱引用-softreference"}},[t._v("#")]),t._v(" 3.弱引用 SoftReference")]),t._v(" "),a("p",[t._v("弱引用也是用来描述"),a("strong",[t._v("非必需对象")]),t._v("的")]),t._v(" "),a("p",[t._v("当JVM进行垃圾回收时，无论内存是否充足，"),a("strong",[t._v("都会回收被弱引用关联的对象")])]),t._v(" "),a("h3",{attrs:{id:"_4-虚引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-虚引用"}},[t._v("#")]),t._v(" 4.虚引用")]),t._v(" "),a("p",[t._v("虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时")]),t._v(" "),a("p",[t._v("如果发现它还有虚引用，就会把这个"),a("strong",[t._v("虚引用加入到与之关联的引用队列中")])]),t._v(" "),a("p",[t._v("可以通过判断引用队列中是否已经加入了虚引用")]),t._v(" "),a("p",[t._v("由Refernce Handler线程调用虚引用相关方法释放直接内存")]),t._v(" "),a("h2",{attrs:{id:"三-垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-垃圾回收算法"}},[t._v("#")]),t._v(" 三.垃圾回收算法")]),t._v(" "),a("h3",{attrs:{id:"_1-标记清除算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-标记清除算法"}},[t._v("#")]),t._v(" 1.标记清除算法")]),t._v(" "),a("p",[t._v("步骤:")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("标记")]),t._v(": 垃圾回收器从引用根节点开始遍历被引用的对象.一般是在Header中记录为可达对象")]),t._v(" "),a("li",[a("strong",[t._v("清除")]),t._v(": 垃圾回收器从堆内存从头到尾进行线性的便利,如果发现某个对象没有被标记,则进行回收")])]),t._v(" "),a("p",[a("strong",[t._v("如何清除?")])]),t._v(" "),a("p",[t._v("把需要清除对象地址保存在空闲的地址列表.")]),t._v(" "),a("p",[t._v("下次有新对象需要加载时,判断垃圾的位置空间是否足够")]),t._v(" "),a("p",[t._v("如果够则覆盖原有的位置")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("优点")]),t._v("是速度快")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("缺点")]),t._v("是容易产生内存碎片")])])]),t._v(" "),a("h3",{attrs:{id:"_2-标记整理算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-标记整理算法"}},[t._v("#")]),t._v(" 2.标记整理算法")]),t._v(" "),a("p",[t._v("步骤:")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("标记")]),t._v(": 垃圾回收器从引用根节点开始遍历被引用的对象.一般是在Header中记录为可达对象")]),t._v(" "),a("li",[a("strong",[t._v("整理")]),t._v(": 将所有存活对象压缩到内存的一段,之后清理边界外所有的空间")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("不会产生较大的内存碎片")])]),t._v(" "),a("li",[a("p",[t._v("但是涉及到内存地址改变,效率较低")])])]),t._v(" "),a("h3",{attrs:{id:"_3-复制算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-复制算法"}},[t._v("#")]),t._v(" 3.复制算法")]),t._v(" "),a("p",[t._v("将内存区域划分成两块")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("FROM")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("To")])])]),t._v(" "),a("tbody")]),t._v(" "),a("p",[t._v("其中FROM区域存放对象,To区域始终空闲")]),t._v(" "),a("p",[t._v("首先在FROM区域中进行标记")]),t._v(" "),a("p",[t._v("将FROM中存活的对象放在TO区域中")]),t._v(" "),a("p",[t._v("接着清除FROM区域中的垃圾")]),t._v(" "),a("p",[t._v("最后交换两块区域")]),t._v(" "),a("ul",[a("li",[t._v("不会有内存碎片")]),t._v(" "),a("li",[t._v("但需要两倍的内存空间")])]),t._v(" "),a("h2",{attrs:{id:"四-分代回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-分代回收算法"}},[t._v("#")]),t._v(" 四.分代回收算法")]),t._v(" "),a("p",[t._v("Java虚拟机根据对象存货周期不同,把"),a("strong",[t._v("堆内存")]),t._v("划分为几块")]),t._v(" "),a("p",[t._v("一般分为"),a("strong",[t._v("新生代")]),t._v(","),a("strong",[t._v("老年代")]),t._v(",在HotSpot中还有"),a("strong",[t._v("永久代")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E6%96%B0%E7%94%9F%E4%BB%A3.png",alt:"image-20230924213403553"}})]),t._v(" "),a("p",[t._v("大小比例为 8 : 1 : 1")]),t._v(" "),a("ul",[a("li",[t._v("大部分刚刚被创建的对象存放在"),a("strong",[t._v("Eden区")])]),t._v(" "),a("li",[t._v("当 Eden区满了以后,触发"),a("strong",[t._v("Minor GC")]),t._v(",使用"),a("strong",[t._v("复制算法")]),t._v("将存活对象放在From区.将From区的对象计数为1")]),t._v(" "),a("li",[t._v("Minor GC时,会引发"),a("strong",[t._v("stop the world")]),t._v(",暂停当前用户正在执行的方法")]),t._v(" "),a("li",[t._v("第二次满以后继续触发GC,将"),a("strong",[t._v("From区")]),t._v("的对象计数为2,当达到阈值(默认为15-4bit)以后晋升"),a("strong",[t._v("老年代")]),t._v("中")]),t._v(" "),a("li",[t._v("当老年代空间不足时,先尝试触发"),a("strong",[t._v("Minor GC")]),t._v(",再触发"),a("strong",[t._v("Full GC")]),t._v(",清理新生代到老年代垃圾")]),t._v(" "),a("li",[t._v("大对象直接晋升老年代")])]),t._v(" "),a("h2",{attrs:{id:"五-gc参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五-gc参数"}},[t._v("#")]),t._v(" 五.GC参数")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("含义")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("参数")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("堆初始大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-Xms")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("堆最大大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-Xmx")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("新生代大小")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-Xmn")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("幸存区比例(动态)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:InitialSurvorRatio=ratio")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("幸存区比例")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:SurvorRatio=ratio")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("晋升阈值")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:MaxTenuringThreshold=threshold")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("晋升详情")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+PrintTenuringDistribution")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("GC详情")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:+PrintGCDetails -verbose:gc")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("FullGC 前 MinorGC")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-XX:ScavengeBeforeFullGC")])])])]),t._v(" "),a("h2",{attrs:{id:"六-垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六-垃圾回收器"}},[t._v("#")]),t._v(" 六.垃圾回收器")]),t._v(" "),a("p",[t._v("垃圾回收器是垃圾回收算法的具体实现")]),t._v(" "),a("h3",{attrs:{id:"_1-serial串行垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-serial串行垃圾回收器"}},[t._v("#")]),t._v(" 1.Serial串行垃圾回收器")]),t._v(" "),a("ul",[a("li",[t._v("单线程")]),t._v(" "),a("li",[t._v("堆内存较小,适合个人电脑")]),t._v(" "),a("li",[t._v("Serial只会使用一个CPU或者一条GC线程进行垃圾回收，并且在线程到达安全点时暂停其他工作线程")]),t._v(" "),a("li",[t._v("新生代使用复制算法,老年代使用标记整理算法")])]),t._v(" "),a("p",[t._v("使用参数命令开启")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseSerialGC")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Serial")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SerialOld")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"_2-parallelgc并行垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-parallelgc并行垃圾回收器"}},[t._v("#")]),t._v(" 2. ParallelGC并行垃圾回收器")]),t._v(" "),a("ul",[a("li",[t._v("多线程")]),t._v(" "),a("li",[t._v("吞吐量大")]),t._v(" "),a("li",[t._v("堆内存较大,多核cpu")]),t._v(" "),a("li",[t._v("尽可能让单次"),a("strong",[t._v("STW")]),t._v("(Stop the world)的次数最少")]),t._v(" "),a("li",[t._v("新生代使用复制算法,老年代使用标记整理算法")])]),t._v(" "),a("p",[t._v("使用参数命令开启")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseParallelGC")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//开启")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UserAdaptiveSizePolicy")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//通过命令就能开启GC 自适应的调节策略(区别于ParNew).")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("GCTimeRatio")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("ratio "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//调整吞吐量大小,GC时间占总时间比率")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxGCpauseMillis")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("ms"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//暂停时间最大毫秒数")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("到达安全点多个线程同时进行垃圾回收")]),t._v(" "),a("h3",{attrs:{id:"_3-cms垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-cms垃圾回收器"}},[t._v("#")]),t._v(" 3.CMS垃圾回收器")]),t._v(" "),a("p",[t._v("CMS作用于老年代，是一种以获取最短停顿时间为目标的收集器。给予标记-清除算法实现")]),t._v(" "),a("h4",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),a("ul",[a("li",[t._v("多线程")]),t._v(" "),a("li",[t._v("吞吐量低")]),t._v(" "),a("li",[t._v("堆内存较大,多核cpu")]),t._v(" "),a("li",[t._v("尽可能让单次STW的时间最短")]),t._v(" "),a("li",[t._v("使用标记-清除算法")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ParalleGCThreads")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("n "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//并发GC线程数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CMSInitiatingOccupancyFraction")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("parent"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//设置CMS触发时机 ")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png",alt:"image-20230925164543603"}})]),t._v(" "),a("h4",{attrs:{id:"步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[t._v("#")]),t._v(" 步骤")]),t._v(" "),a("p",[t._v("1.初始标记\n停止一切用户线程，因使用一条初始标记线程对所有与GC Roots关联的对象进行标记。\n2.并发标记\n使用多条并发标记线程并行执行，并与用户线程并发执行。此过程进行可达性分析，标记出所有废弃的对象，速度很慢。\n3.重新标记\n使用多条线程并行执行，将刚才并发过程中新出现的废弃对象标出来。\n4.并发清除\n使用一条并发清除线程，和业务线程并发执行，清除无用对象，这个过程非常耗时。此时可能会产生浮动垃圾")]),t._v(" "),a("h2",{attrs:{id:"七-g1垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七-g1垃圾回收器"}},[t._v("#")]),t._v(" 七.G1垃圾回收器")]),t._v(" "),a("h3",{attrs:{id:"_1-g1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-g1"}},[t._v("#")]),t._v(" 1.G1")]),t._v(" "),a("p",[t._v("①. G1(Garbage-First)是一款面向服务端应用的垃圾收集器,主要针对配备多核CPU及大容量内存的机器,"),a("strong",[t._v("以极高概率满足GC停顿时间的同时")]),t._v(",还"),a("strong",[t._v("兼具高吞吐量的性能特征")])]),t._v(" "),a("p",[t._v("②. 在JDK1.7版本正式启用,是"),a("strong",[t._v("JDK 9以后的默认垃圾收集器,取代了CMS 回收器")]),t._v("。")]),t._v(" "),a("p",[t._v("使用场景:")]),t._v(" "),a("ul",[a("li",[t._v("同时注重吞吐量和低延迟,默认的暂停量是200ms")]),t._v(" "),a("li",[t._v("超大堆内存,会将堆划分为多个大小相等的Region,用来表示Eden,s0,s1,old区等")]),t._v(" "),a("li",[t._v("整体上是"),a("strong",[t._v("标记整理")]),t._v("算法,两个区域直接按是"),a("strong",[t._v("复制")]),t._v("算法")])]),t._v(" "),a("h3",{attrs:{id:"_2-参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-参数"}},[t._v("#")]),t._v(" 2.参数")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("G1HeapRegionSize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("size"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//设置Region区域大小,增加标记速度")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxGCPauseMillis")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//设置期望达到的最大GC停顿时间指标")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h3",{attrs:{id:"_3-分区region"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-分区region"}},[t._v("#")]),t._v(" 3.分区Region")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png",alt:"image-20230925174058171"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("G1垃圾收集器还增加了一种新的内存区域，叫做"),a("strong",[t._v("Humongous内存区域")]),t._v("，如图中的H块。主要用于存储大对象，如果"),a("strong",[t._v("超过1.5个region, 就放到H")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("内存的回收是"),a("strong",[t._v("以region作为基本单位的")]),t._v("。Region之间是复制算法,但整体上实际可看作是"),a("strong",[t._v("标记一压缩(Mark一Compact)算法")]),t._v(",两种算法都可以避免内存碎片。这种特性有利于程序长时间运行,分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候,G1的优势更加明显)")])])]),t._v(" "),a("h3",{attrs:{id:"_4-垃圾回收阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-垃圾回收阶段"}},[t._v("#")]),t._v(" 4.垃圾回收阶段")]),t._v(" "),a("h4",{attrs:{id:"_1-新生代回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-新生代回收"}},[t._v("#")]),t._v(" 1).新生代回收")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("当Eden空间耗尽时,G1会启动一次年轻代垃圾回收过程")])]),t._v(" "),a("li",[a("strong",[t._v("年轻代垃圾回收只会回收Eden区和Survivor区")])])]),t._v(" "),a("p",[t._v("阶段")]),t._v(" "),a("ol",[a("li",[t._v("根扫描\n"),a("ul",[a("li",[t._v("考虑"),a("strong",[t._v("remembered Set")]),t._v(",看是否由老年代中的对象引用了新生代对象")]),t._v(" "),a("li",[t._v("根是指static变量指向的对象,正在执行的方法调用链条上的局部变量等")])])]),t._v(" "),a("li",[t._v("更新RSet")])]),t._v(" "),a("p",[t._v("此阶段完成后,Rest可以准确的反映老年代对所在的内存分段中对象的引用")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("处理RSet\n"),a("ul",[a("li",[t._v("识别被老年代对象指向的Eden中的对象,这些被只想的Eden中的对象被认为是存活的对象")])])]),t._v(" "),a("li",[t._v("复制对象")])]),t._v(" "),a("p",[t._v("Eden区 内存段中"),a("strong",[t._v("存活的对象")]),t._v("会被"),a("strong",[t._v("复制")]),t._v("到"),a("strong",[t._v("Survivor区中空的内存分段")]),t._v(",Survivor区内存段中"),a("strong",[t._v("存活的对象如果年龄未达阈值")]),t._v(",年龄会加1,"),a("strong",[t._v("达到阀值会被会被复制到old区中空的内存分段")]),t._v("。如果"),a("strong",[t._v("Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间")])]),t._v(" "),a("h4",{attrs:{id:"_2-老年代并发标记过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-老年代并发标记过程"}},[t._v("#")]),t._v(" 2).老年代并发标记过程")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("在YoungGC时会进行GC Root的初始标记,STW,并触发一次"),a("strong",[t._v("Minor GC")])])]),t._v(" "),a("li",[a("p",[t._v("老年代占用堆内存比例大道阈值时,进行并发标记(不会STW),由下面的JVM参数决定")])])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InitiatingHeadOccupancyPercent")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("percent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("默认"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("45")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("再次标记修正上一次的结果")]),t._v(" "),a("li",[t._v("识别可以混合回收的区域.")]),t._v(" "),a("li",[t._v("识别并清理完全空闲的区域")])]),t._v(" "),a("h4",{attrs:{id:"_3-混合收集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-混合收集"}},[t._v("#")]),t._v(" 3).混合收集")]),t._v(" "),a("p",[t._v("对Eden,survivor,old区进行全面垃圾回收,主要采用复制算法")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("XX")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxGCPauseeMillis")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("ms "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//最大暂停时间")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("GC从老年区间移动存活对象到空闲区间,这些空闲区间也就成为了老年代的一部分")])])}),[],!1,null,null,null);a.default=r.exports}}]);