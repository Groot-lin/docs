(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{483:function(v,s,e){"use strict";e.r(s);var t=e(2),_=Object(t.a)({},(function(){var v=this,s=v._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("p",[v._v("在"),s("a",{attrs:{href:"./Redis%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"}},[v._v("Redis主从集群")]),v._v("中我们聊过")]),v._v(" "),s("p",[v._v("slave节点宕机恢复后可以找master节点同步数据")]),v._v(" "),s("blockquote",[s("p",[v._v("master节点宕机怎么办?")])]),v._v(" "),s("p",[v._v("master宕机以后无法进行写入")]),v._v(" "),s("p",[v._v("Redis可用性会下降")]),v._v(" "),s("p",[v._v("有人提出了这样一种解决方案 :")]),v._v(" "),s("p",[v._v("我们持续监控Redis各个节点的健康状态")]),v._v(" "),s("p",[v._v("一旦发现master宕机")]),v._v(" "),s("p",[v._v("立即选择一个slave节点作为master")]),v._v(" "),s("p",[v._v("master就变成了slave节点")]),v._v(" "),s("p",[v._v("这就是"),s("strong",[v._v("哨兵(Sentinel)模式")]),v._v("!")]),v._v(" "),s("h3",{attrs:{id:"哨兵的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哨兵的作用"}},[v._v("#")]),v._v(" 哨兵的作用")]),v._v(" "),s("p",[v._v("我们知道")]),v._v(" "),s("p",[v._v("Redis提供哨兵(Sentinel)机制来是实现主从集群的自动故障恢复")]),v._v(" "),s("p",[v._v("哨兵结构如下 :")]),v._v(" "),s("p",[s("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/Redis%E5%93%A8%E5%85%B5.png",alt:"image-20231122145809817"}})]),v._v(" "),s("p",[v._v("具体作用为 :")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("监控")]),v._v(" : Sentinel会不断检查Redis的master和slave是否按预期工作")]),v._v(" "),s("li",[s("strong",[v._v("自动故障恢复")]),v._v(" : 如果master故障,Sentinel会将一个slave提升为master.当故障实例恢复后也以新的master为主")]),v._v(" "),s("li",[s("strong",[v._v("通知")]),v._v(" : Sentinel充当Redis客户端的服务发现来源,当集群发生故障转移时,会将最新信息推送给Redis客户端")])]),v._v(" "),s("h3",{attrs:{id:"服务状态监控"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务状态监控"}},[v._v("#")]),v._v(" 服务状态监控")]),v._v(" "),s("blockquote",[s("p",[v._v("那么哨兵是如何得知Redis节点的工作状态的呢?")])]),v._v(" "),s("p",[v._v("Sentinel基于"),s("strong",[v._v("心跳机制")]),v._v("检测服务状态,每个1秒向集群的每个实例发送ping命令 :")]),v._v(" "),s("p",[v._v("根据Redis节点是否返回pong的响应来判断Redis是否下线")]),v._v(" "),s("p",[v._v("这里分为两种情况 :")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("主观下线")]),v._v(" : 如果某个sentinel节点发现某实例未在规定时间响应,则认为该实例主观下线")]),v._v(" "),s("li",[s("strong",[v._v("客观下线")]),v._v(" : 若超过指定数量(quorum)的sentinel都认为该实主观下线,则该实例"),s("strong",[v._v("客观下线")]),v._v(".quorum值最好超过Sentinel实例数量的一半")])]),v._v(" "),s("h3",{attrs:{id:"master选举机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#master选举机制"}},[v._v("#")]),v._v(" master选举机制")]),v._v(" "),s("p",[v._v("一旦发现master故障,sentinel需要在slave中选择一个作为新的master,选择依据为 :")]),v._v(" "),s("ol",[s("li",[v._v("首先会判断slave节点与master节点"),s("strong",[v._v("断开时间长短")]),v._v("，如果超过指定值（down-after-milliseconds*10)则会排除该slave节点")]),v._v(" "),s("li",[v._v("然后判断slave节点的"),s("strong",[v._v("slave-priority值")]),v._v(",越小优先级越高,如果是0则用不参与选举")]),v._v(" "),s("li",[v._v("如果slave-prority一样,则判断slave节点的"),s("strong",[v._v("offset值")]),v._v(",越大说明数据越新,优先级越高(即判断数据同步进度)")]),v._v(" "),s("li",[v._v("最后判断slave节点的运行id大小,越小优先级越高")])]),v._v(" "),s("h3",{attrs:{id:"如何实现故障转移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现故障转移"}},[v._v("#")]),v._v(" 如何实现故障转移")]),v._v(" "),s("p",[v._v("举个例子:")]),v._v(" "),s("p",[v._v("如图有三个节点7001(master),7002,7003")]),v._v(" "),s("p",[v._v("现在master节点宕机")]),v._v(" "),s("p",[s("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/Sentinel%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png",alt:"image-20231122151802836"}})]),v._v(" "),s("ol",[s("li",[v._v("sentinel给备选的slave1节点发送"),s("strong",[v._v("slaveof no one")]),v._v("命令，让该节点成为master")]),v._v(" "),s("li",[v._v("sentinel给所有其它slave发送slaveof 192.168.150.101 7002命令，让这些slave成为新master的从节点，开始从新的master上同步数据")]),v._v(" "),s("li",[v._v("最后，sentinel"),s("strong",[v._v("将故障节点标记为slave")]),v._v("，当故障节点恢复后会自动成为新的master的slave节点")])])])}),[],!1,null,null,null);s.default=_.exports}}]);