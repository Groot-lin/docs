(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{479:function(v,_,s){"use strict";s.r(_);var t=s(2),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("我们知道")]),v._v(" "),_("p",[_("a",{attrs:{href:"./Redis%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"}},[v._v("主从模式")]),v._v("和"),_("a",{attrs:{href:"./Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"}},[v._v("哨兵模式")]),v._v("可以分别解决高并发读和高可用的问题")]),v._v(" "),_("p",[v._v("但是现在任然存在两个问题")]),v._v(" "),_("ul",[_("li",[v._v("海量数据存储")]),v._v(" "),_("li",[v._v("高并发写")])]),v._v(" "),_("p",[v._v("使用分片集群可以解决上述问题")]),v._v(" "),_("p",[v._v("分片集群特征有 :")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("集群中有多个master,每个master保存不同数据")])]),v._v(" "),_("li",[_("p",[v._v("每个master都可以有多个slave节点,构成局部主从关系")])]),v._v(" "),_("li",[_("p",[v._v("master之间通过"),_("strong",[v._v("ping")]),v._v("监测彼此健康状态,不需要哨兵机制")])]),v._v(" "),_("li",[_("p",[v._v("客户端请求可以访问集群任意几点,最终都会被争取转发")])])]),v._v(" "),_("h2",{attrs:{id:"一-散列插槽"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一-散列插槽"}},[v._v("#")]),v._v(" 一.散列插槽")]),v._v(" "),_("p",[v._v("查看集群信息时,我们发现每个master节点都有一部分"),_("strong",[v._v("slots")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://18334034784.oss-cn-chengdu.aliyuncs.com/lin-oss/slots.png",alt:"image-20231122160711206"}})]),v._v(" "),_("p",[v._v("Redis会把每一个master节点映射到0~16383共"),_("strong",[v._v("16384")]),v._v("个插槽( hash slot)上")]),v._v(" "),_("p",[v._v("每个节点都分配一部分")]),v._v(" "),_("p",[v._v("我们知道,Redis是键值型数据库")]),v._v(" "),_("p",[v._v("而数据key不是与节点绑定,而是与插槽绑定.")]),v._v(" "),_("p",[_("strong",[v._v("redis会更具key的有效部份计算slots值")]),v._v(" :")]),v._v(" "),_("ul",[_("li",[v._v('key中包含"{}",且"{}"中至少包含1个字符,则"{}"中的部分是有效部分')]),v._v(" "),_("li",[v._v('key中不包含"{}",整个key都是有效部分')])]),v._v(" "),_("p",[v._v("例如:")]),v._v(" "),_("p",[v._v("key是num,num是有效部分")]),v._v(" "),_("p",[v._v('key是{lin}num,则根据"lin"计算')]),v._v(" "),_("p",[v._v("计算方式是利用CRC16算法得到一个hash值,然后对16384取余,得到的结果就是"),_("strong",[v._v("slot值")])]),v._v(" "),_("p",[v._v("就知道key应该存储到哪个节点了")]),v._v(" "),_("p",[v._v("问题来了")]),v._v(" "),_("blockquote",[_("p",[v._v("为什么key绑定插槽而不绑定节点?")])]),v._v(" "),_("p",[v._v("这是因为节点可以能出现宕机的情况")]),v._v(" "),_("p",[v._v("绑定了插槽,在节点宕机后转移插槽或者扩容时转移插槽")]),v._v(" "),_("blockquote",[_("p",[v._v("如何将同一类数据固定保存在同一个Redis实例?")])]),v._v(" "),_("p",[v._v("我们可以使"),_("strong",[v._v("key的有效部分一致")]),v._v(",通过算法就获得了相同slot值,就能定位到同一个实例")]),v._v(" "),_("h2",{attrs:{id:"二-集群伸缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二-集群伸缩"}},[v._v("#")]),v._v(" 二.集群伸缩")]),v._v(" "),_("p",[v._v("Redis集群提供了灵活的节点扩容和收缩方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容")]),v._v(" "),_("p",[v._v("Redis分片集群中如何添加节点和删除节点呢,我们来简单了解一下")]),v._v(" "),_("p",[v._v("添加节点")]),v._v(" "),_("div",{staticClass:"language-shell line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[v._v("add-node new_host:new_port existing_host:existing_port\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 新ip:新端口 已存在ip:已存在端口")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("p",[v._v("迁移槽和数据")]),v._v(" "),_("p",[v._v("从其他节点中分配一些槽位")]),v._v(" "),_("h2",{attrs:{id:"三-故障转移"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三-故障转移"}},[v._v("#")]),v._v(" 三.故障转移")]),v._v(" "),_("p",[v._v("前面提到")]),v._v(" "),_("p",[v._v("分片集群中没有哨兵模式")]),v._v(" "),_("p",[v._v("但是也可以做到故障转移")]),v._v(" "),_("blockquote",[_("p",[v._v("当集群中有一个master宕机会发生什么?")])]),v._v(" "),_("ol",[_("li",[v._v("首先该实例与其他实例失去连接")]),v._v(" "),_("li",[v._v("然后疑似宕机")]),v._v(" "),_("li",[v._v("最后确定下线,自动提升一个slave为新的master")])]),v._v(" "),_("p",[v._v("这是意外宕机的自动故障转移")]),v._v(" "),_("p",[v._v("但是Redis中的master节点可能会老旧需要维护")]),v._v(" "),_("p",[v._v("我们需要做的就是手动故障转移")]),v._v(" "),_("p",[v._v("在原的master节点利用"),_("font",{attrs:{color:"red"}},[v._v("cluster failover")]),v._v("命令手动让集群中的某个master宕机,切换到命令执行的slave节点,实现无感知的数据迁移")],1),v._v(" "),_("ol",[_("li",[v._v("slave节点告诉master,节点拒绝任何客户端请求")]),v._v(" "),_("li",[v._v("master返回当前数据offset给slave")]),v._v(" "),_("li",[v._v("slave等待数据offset与master一致")]),v._v(" "),_("li",[v._v("开始故障转移")]),v._v(" "),_("li",[v._v("标记自己为master")]),v._v(" "),_("li",[v._v("开始处理客户端请求")])])])}),[],!1,null,null,null);_.default=e.exports}}]);